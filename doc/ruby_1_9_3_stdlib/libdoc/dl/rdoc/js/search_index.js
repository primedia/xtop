var search_data = {"index":{"searchIndex":["dl","basictypes","cfunc","cparser","cptr","cstruct","cstructbuilder","cstructentity","cunion","cunionentity","carriedfunction","compositehandler","dlerror","dltypeerror","fiddle","function","handle","importer","packinfo","packer","stack","tempfunction","valueutil","win32types","object","win32","registry","api","constants","error","kernel32","predefinedkey","resolv","kernel32","sspi","api","identity","negotiateauth","sspiresult","securitybuffer","securityhandle","timestamp","win32api","+()","+@()","-()","-@()","<=>()","==()","==()","call()","closekey()","createkey()","deletekey()","deletevalue()","enumkey()","enumvalue()","flushkey()","openkey()","queryinfokey()","queryvalue()","setvalue()","[]()","[]()","[]()","[]()","[]()","[]()","[]()","[]()","[]()","[]()","[]()","[]=()","[]=()","[]=()","_dump()","align()","assign_names()","bind()","bind()","bind_at_call()","bind_at_call()","bind_at_call()","bind_function()","bound?()","buffersize()","buffertype()","call()","call()","call()","calltype()","calltype=()","check()","class()","close()","close()","close()","close_enabled?()","complete_authentication()","create()","create()","create()","create_carried_function()","create_carrier()","create_temp_function()","create_value()","created?()","ctype()","ctype=()","delete()","delete_key()","delete_value()","disable_close()","dlload()","dlopen()","dlunwrap()","dlwrap()","each()","each_key()","each_value()","enable_close()","entity_class()","entity_class()","eql?()","expand_environ()","extern()","fiddle?()","flush()","foreach_proc_entry()","free()","free()","free=()","func_name()","gen_callback_file()","gen_push_addr_ary()","gen_push_proc_ary()","gencallback()","get_hosts_path()","get_initial_token()","get_resolv_info()","handler()","handlers()","import_function()","import_symbol()","import_value()","info()","inspect()","inspect()","inspect()","keys()","last_error()","lower()","malloc()","malloc()","malloc()","malloc()","name()","name()","name()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","null?()","ok?()","open()","open()","open?()","pack()","pack()","packdw()","packqw()","parse_ctype()","parse_signature()","parse_struct_signature()","proxy_auth_get()","ptr()","ptr()","ptr=()","read()","read_bin()","read_i()","read_s()","read_s_expand()","realloc()","ref()","remove_callback()","remove_callback_internal()","remove_cdecl_callback()","remove_stdcall_callback()","set_callback()","set_callback_internal()","set_cdecl_callback()","set_ctypes()","set_ctypes()","set_stdcall_callback()","signed_value()","size()","size()","size()","size()","size()","size=()","sizeof()","struct()","sym()","sym()","sym()","time2wtime()","to_i()","to_i()","to_i()","to_i()","to_int()","to_p()","to_p()","to_p()","to_p()","to_ptr()","to_s()","to_s()","to_s()","to_s()","to_str()","to_value()","token()","type2name()","typealias()","types()","unbind()","unbind_at_call()","unbind_at_call()","union()","unpack()","unpack()","unpackdw()","unpackqw()","unsigned_value()","upper()","value()","win32_last_error()","wrap_arg()","wrap_args()","wrap_result()","write()","write_bin()","write_i()","write_s()","wtime2time()"],"longSearchIndex":["dl","dl::basictypes","dl::cfunc","dl::cparser","dl::cptr","dl::cstruct","dl::cstructbuilder","dl::cstructentity","dl::cunion","dl::cunionentity","dl::carriedfunction","dl::compositehandler","dl::dlerror","dl::dltypeerror","dl::fiddle","dl::function","dl::handle","dl::importer","dl::packinfo","dl::packer","dl::stack","dl::tempfunction","dl::valueutil","dl::win32types","object","win32","win32::registry","win32::registry::api","win32::registry::constants","win32::registry::error","win32::registry::error::kernel32","win32::registry::predefinedkey","win32::resolv","win32::resolv::kernel32","win32::sspi","win32::sspi::api","win32::sspi::identity","win32::sspi::negotiateauth","win32::sspi::sspiresult","win32::sspi::securitybuffer","win32::sspi::securityhandle","win32::sspi::timestamp","win32api","dl::cptr#+()","dl::cptr#+@()","dl::cptr#-()","dl::cptr#-@()","dl::cptr#<=>()","dl::cptr#==()","win32::sspi::sspiresult#==()","win32api#call()","win32::registry::api#closekey()","win32::registry::api#createkey()","win32::registry::api#deletekey()","win32::registry::api#deletevalue()","win32::registry::api#enumkey()","win32::registry::api#enumvalue()","win32::registry::api#flushkey()","win32::registry::api#openkey()","win32::registry::api#queryinfokey()","win32::registry::api#queryvalue()","win32::registry::api#setvalue()","dl::cfunc#[]()","dl::cptr#[]()","dl::cptr::[]()","dl::cstructentity#[]()","dl::compositehandler#[]()","dl::handle::[]()","dl::handle#[]()","dl::importer#[]()","dl::packer::[]()","dl::stack::[]()","win32::registry#[]()","dl::cptr#[]=()","dl::cstructentity#[]=()","win32::registry#[]=()","win32::registry#_dump()","dl::packinfo::align()","dl::cstructentity#assign_names()","dl::function#bind()","dl::importer#bind()","dl::carriedfunction#bind_at_call()","dl::function#bind_at_call()","dl::tempfunction#bind_at_call()","dl::importer#bind_function()","dl::function#bound?()","win32::sspi::securitybuffer#buffersize()","win32::sspi::securitybuffer#buffertype()","dl::cfunc#call()","dl::function#call()","win32api#call()","dl::cfunc#calltype()","dl::cfunc#calltype=()","win32::registry::api#check()","win32::registry::predefinedkey#class()","dl::handle#close()","win32::registry#close()","win32::registry::predefinedkey#close()","dl::handle#close_enabled?()","win32::sspi::negotiateauth#complete_authentication()","dl::cstructbuilder::create()","win32::registry#create()","win32::registry::create()","dl::importer#create_carried_function()","dl::carriedfunction#create_carrier()","dl::importer#create_temp_function()","dl::importer#create_value()","win32::registry#created?()","dl::cfunc#ctype()","dl::cfunc#ctype=()","win32::registry#delete()","win32::registry#delete_key()","win32::registry#delete_value()","dl::handle#disable_close()","dl::importer#dlload()","dl::dlopen()","dl::dlunwrap()","dl::dlwrap()","win32::registry#each()","win32::registry#each_key()","win32::registry#each_value()","dl::handle#enable_close()","dl::cstruct::entity_class()","dl::cunion::entity_class()","dl::cptr#eql?()","win32::registry::expand_environ()","dl::importer#extern()","dl::fiddle?()","win32::registry#flush()","object#foreach_proc_entry()","dl::free()","dl::cptr#free()","dl::cptr#free=()","object#func_name()","object#gen_callback_file()","object#gen_push_addr_ary()","object#gen_push_proc_ary()","object#gencallback()","win32::resolv::get_hosts_path()","win32::sspi::negotiateauth#get_initial_token()","win32::resolv::get_resolv_info()","dl::importer#handler()","dl::compositehandler#handlers()","dl::importer#import_function()","dl::importer#import_symbol()","dl::importer#import_value()","win32::registry#info()","dl::cfunc#inspect()","dl::cptr#inspect()","win32::registry#inspect()","win32::registry#keys()","dl::cfunc::last_error()","win32::sspi::securityhandle#lower()","dl::malloc()","dl::cptr::malloc()","dl::cstructentity::malloc()","dl::cunionentity::malloc()","dl::cfunc#name()","dl::function#name()","win32::registry#name()","dl::cfunc::new()","dl::cptr::new()","dl::cstructentity::new()","dl::carriedfunction::new()","dl::compositehandler::new()","dl::function::new()","dl::handle::new()","dl::packer::new()","dl::stack::new()","win32::registry::new()","win32::registry::error::new()","win32::registry::predefinedkey::new()","win32::sspi::identity::new()","win32::sspi::negotiateauth::new()","win32::sspi::sspiresult::new()","win32::sspi::securitybuffer::new()","win32api::new()","dl::cptr#null?()","win32::sspi::sspiresult#ok?()","win32::registry::open()","win32::registry#open()","win32::registry#open?()","dl::packer#pack()","dl::stack#pack()","win32::registry::api#packdw()","win32::registry::api#packqw()","dl::cparser#parse_ctype()","dl::cparser#parse_signature()","dl::cparser#parse_struct_signature()","win32::sspi::negotiateauth::proxy_auth_get()","dl::cfunc#ptr()","dl::cptr#ptr()","dl::cfunc#ptr=()","win32::registry#read()","win32::registry#read_bin()","win32::registry#read_i()","win32::registry#read_s()","win32::registry#read_s_expand()","dl::realloc()","dl::cptr#ref()","dl#remove_callback()","dl#remove_callback_internal()","dl#remove_cdecl_callback()","dl#remove_stdcall_callback()","dl#set_callback()","dl#set_callback_internal()","dl#set_cdecl_callback()","dl::cstructentity#set_ctypes()","dl::cunionentity#set_ctypes()","dl#set_stdcall_callback()","dl::valueutil#signed_value()","dl::cptr#size()","dl::cstructentity::size()","dl::cunionentity::size()","dl::packer#size()","dl::stack#size()","dl::cptr#size=()","dl::importer#sizeof()","dl::importer#struct()","dl::compositehandler#sym()","dl::handle#sym()","dl::handle::sym()","win32::registry::time2wtime()","dl::cfunc#to_i()","dl::cptr#to_i()","dl::function#to_i()","dl::handle#to_i()","dl::cptr#to_int()","win32::sspi::identity#to_p()","win32::sspi::securitybuffer#to_p()","win32::sspi::securityhandle#to_p()","win32::sspi::timestamp#to_p()","dl::cptr::to_ptr()","dl::cfunc#to_s()","dl::cptr#to_s()","dl::cstructentity#to_s()","win32::sspi::sspiresult#to_s()","dl::cptr#to_str()","dl::cptr#to_value()","win32::sspi::securitybuffer#token()","win32::registry::type2name()","dl::importer#typealias()","dl::stack#types()","dl::function#unbind()","dl::function#unbind_at_call()","dl::tempfunction#unbind_at_call()","dl::importer#union()","dl::packer#unpack()","dl::stack#unpack()","win32::registry::api#unpackdw()","win32::registry::api#unpackqw()","dl::valueutil#unsigned_value()","win32::sspi::securityhandle#upper()","dl::importer#value()","dl::cfunc::win32_last_error()","dl::valueutil#wrap_arg()","dl::valueutil#wrap_args()","dl::function#wrap_result()","win32::registry#write()","win32::registry#write_bin()","win32::registry#write_i()","win32::registry#write_s()","win32::registry::wtime2time()"],"info":[["DL","","DL.html","","<p>A bridge to the dlopen() or dynamic library linker function.\n<p>Example\n\n<pre>bash $&gt; cat &gt; sum.c &lt;&lt;EOF\ndouble sum(double ...</pre>\n"],["DL::BasicTypes","","DL/BasicTypes.html","","<p>Adds basic type aliases to the including class for use with DL::Importer.\n<p>The aliases added are <code>uint</code> and …\n"],["DL::CFunc","","DL/CFunc.html","","<p>A direct accessor to a function in a C library\n<p>Example\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">libc_so</span> = <span class=\"ruby-string\">&quot;/lib64/libc.so.6&quot;</span>\n=<span class=\"ruby-operator\">&gt;</span> <span class=\"ruby-string\">&quot;/lib64/libc.so.6&quot;</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["DL::CParser","","DL/CParser.html","",""],["DL::CPtr","","DL/CPtr.html","","<p>CPtr is a class to handle C pointers\n"],["DL::CStruct","","DL/CStruct.html","",""],["DL::CStructBuilder","","DL/CStructBuilder.html","",""],["DL::CStructEntity","","DL/CStructEntity.html","",""],["DL::CUnion","","DL/CUnion.html","",""],["DL::CUnionEntity","","DL/CUnionEntity.html","",""],["DL::CarriedFunction","","DL/CarriedFunction.html","",""],["DL::CompositeHandler","","DL/CompositeHandler.html","",""],["DL::DLError","","DL/DLError.html","","<p>standard dynamic load exception\n"],["DL::DLTypeError","","DL/DLTypeError.html","","<p>dynamic load incorrect type exception\n"],["DL::Fiddle","","DL/Fiddle.html","",""],["DL::Function","","DL/Function.html","",""],["DL::Handle","","DL/Handle.html","","<p>The DL::Handle is the manner to access the dynamic library\n<p>Example\n<p>Setup\n"],["DL::Importer","","DL/Importer.html","","<p>DL::Importer includes the means to dynamically load libraries and build\nmodules around them including …\n"],["DL::PackInfo","","DL/PackInfo.html","",""],["DL::Packer","","DL/Packer.html","",""],["DL::Stack","","DL/Stack.html","",""],["DL::TempFunction","","DL/TempFunction.html","",""],["DL::ValueUtil","","DL/ValueUtil.html","",""],["DL::Win32Types","","DL/Win32Types.html","","<p>Adds Windows type aliases to the including class for use with DL::Importer.\n<p>The aliases added are:\n<p>ATOM …\n"],["Object","","Object.html","",""],["Win32","","Win32.html","","<p>Implements bindings to Win32 SSPI functions, focused on authentication to a\nproxy server over HTTP.\n"],["Win32::Registry","","Win32/Registry.html","","<p>Win32 Registry\n<p>win32/registry is registry accessor library for Win32 platform. It uses\ndl/import to call …\n"],["Win32::Registry::API","","Win32/Registry/API.html","","<p>Win32 APIs\n"],["Win32::Registry::Constants","","Win32/Registry/Constants.html","","<p>For detail, see the MSDN.\n<p>— HKEY_*\n\n<pre>Predefined key ((*handle*)).\nThese are Integer, not Win32::Registry.</pre>\n"],["Win32::Registry::Error","","Win32/Registry/Error.html","","<p>Error\n"],["Win32::Registry::Error::Kernel32","","Win32/Registry/Error/Kernel32.html","",""],["Win32::Registry::PredefinedKey","","Win32/Registry/PredefinedKey.html","","<p>Predefined Keys\n"],["Win32::Resolv","","Win32/Resolv.html","",""],["Win32::Resolv::Kernel32","","Win32/Resolv/Kernel32.html","",""],["Win32::SSPI","","Win32/SSPI.html","",""],["Win32::SSPI::API","","Win32/SSPI/API.html","","<p>Win32 API Functions. Uses Win32API to bind methods to constants contained\nin class.\n"],["Win32::SSPI::Identity","","Win32/SSPI/Identity.html","","<p>SEC_WINNT_AUTH_IDENTITY structure\n"],["Win32::SSPI::NegotiateAuth","","Win32/SSPI/NegotiateAuth.html","","<p>Handles “Negotiate” type authentication. Geared towards authenticating with\na proxy server …\n"],["Win32::SSPI::SSPIResult","","Win32/SSPI/SSPIResult.html","","<p>Takes a return result from an SSPI function and interprets the value.\n"],["Win32::SSPI::SecurityBuffer","","Win32/SSPI/SecurityBuffer.html","","<p>Creates binary representaiton of a SecBufferDesc structure, including the\nSecBuffer contained inside. …\n"],["Win32::SSPI::SecurityHandle","","Win32/SSPI/SecurityHandle.html","","<p>SecHandle struct\n"],["Win32::SSPI::TimeStamp","","Win32/SSPI/TimeStamp.html","","<p>TimeStamp struct\n"],["Win32API","","Win32API.html","",""],["+","DL::CPtr","DL/CPtr.html#method-i-2B","(p1)","<p>Returns a new DL::CPtr that has been advanced <code>n</code> bytes.\n"],["+@","DL::CPtr","DL/CPtr.html#method-i-2B-40","()","<p>Returns a DL::CPtr that is a dereferenced pointer for this DL::CPtr.\nAnalogous to the star operator in …\n"],["-","DL::CPtr","DL/CPtr.html#method-i-2D","(p1)","<p>Returns a new DL::CPtr that has been moved back <code>n</code> bytes.\n"],["-@","DL::CPtr","DL/CPtr.html#method-i-2D-40","()","<p>Returns a DL::CPtr that is a reference pointer for this DL::CPtr. Analogous\nto the ampersand operator …\n"],["<=>","DL::CPtr","DL/CPtr.html#method-i-3C-3D-3E","(p1)","<p>Returns -1 if less than, 0 if equal to, 1 if greater than\n<code>other</code>.  Returns nil if <code>ptr</code> cannot be compared …\n"],["==","DL::CPtr","DL/CPtr.html#method-i-3D-3D","(p1)","<p>Returns true if <code>other</code> wraps the same pointer, otherwise\nreturns false.\n"],["==","Win32::SSPI::SSPIResult","Win32/SSPI/SSPIResult.html#method-i-3D-3D","(other)",""],["Call","Win32API","Win32API.html#method-i-Call","(*args)",""],["CloseKey","Win32::Registry::API","Win32/Registry/API.html#method-i-CloseKey","(hkey)",""],["CreateKey","Win32::Registry::API","Win32/Registry/API.html#method-i-CreateKey","(hkey, name, opt, desired)",""],["DeleteKey","Win32::Registry::API","Win32/Registry/API.html#method-i-DeleteKey","(hkey, name)",""],["DeleteValue","Win32::Registry::API","Win32/Registry/API.html#method-i-DeleteValue","(hkey, name)",""],["EnumKey","Win32::Registry::API","Win32/Registry/API.html#method-i-EnumKey","(hkey, index)",""],["EnumValue","Win32::Registry::API","Win32/Registry/API.html#method-i-EnumValue","(hkey, index)",""],["FlushKey","Win32::Registry::API","Win32/Registry/API.html#method-i-FlushKey","(hkey)",""],["OpenKey","Win32::Registry::API","Win32/Registry/API.html#method-i-OpenKey","(hkey, name, opt, desired)",""],["QueryInfoKey","Win32::Registry::API","Win32/Registry/API.html#method-i-QueryInfoKey","(hkey)",""],["QueryValue","Win32::Registry::API","Win32/Registry/API.html#method-i-QueryValue","(hkey, name)",""],["SetValue","Win32::Registry::API","Win32/Registry/API.html#method-i-SetValue","(hkey, name, type, data, size)",""],["[]","DL::CFunc","DL/CFunc.html#method-i-5B-5D","(p1)","<p>Calls the function pointer passing in <code>ary</code> as values to the\nunderlying C function.  The return value depends …\n"],["[]","DL::CPtr","DL/CPtr.html#method-i-5B-5D","(p1, p2 = v2)","<p>Returns integer stored at <em>index</em>.  If <em>start</em> and\n<em>length</em> are given, a string containing the bytes from  …\n"],["[]","DL::CPtr","DL/CPtr.html#method-c-5B-5D","(p1)","<p>Get the underlying pointer for ruby object <code>val</code> and return it\nas a DL::CPtr object.\n"],["[]","DL::CStructEntity","DL/CStructEntity.html#method-i-5B-5D","(name)",""],["[]","DL::CompositeHandler","DL/CompositeHandler.html#method-i-5B-5D","(symbol)",""],["[]","DL::Handle","DL/Handle.html#method-c-5B-5D","(p1)","<p>Get the address as an Integer for the function named <code>name</code>.\n"],["[]","DL::Handle","DL/Handle.html#method-i-5B-5D","(p1)","<p>Get the address as an Integer for the function named <code>name</code>.\n"],["[]","DL::Importer","DL/Importer.html#method-i-5B-5D","(name)",""],["[]","DL::Packer","DL/Packer.html#method-c-5B-5D","(*types)",""],["[]","DL::Stack","DL/Stack.html#method-c-5B-5D","(*types)",""],["[]","Win32::Registry","Win32/Registry.html#method-i-5B-5D","(name, *rtype)","<p>Read a registry value named name and return its value data. The class of\nvalue is same as #read method …\n"],["[]=","DL::CPtr","DL/CPtr.html#method-i-5B-5D-3D","(p1, p2, p3 = v3)","<p>Set the value at <code>index</code> to <code>int</code>.  Or, set the\nmemory at <code>start</code> until <code>length</code> with the contents of\n<code>string</code> …\n"],["[]=","DL::CStructEntity","DL/CStructEntity.html#method-i-5B-5D-3D","(name, val)",""],["[]=","Win32::Registry","Win32/Registry.html#method-i-5B-5D-3D","(name, rtype, value = nil)","<p>Write value to a registry value named name.\n<p>If wtype is specified, the value type is it. Otherwise, the …\n"],["_dump","Win32::Registry","Win32/Registry.html#method-i-_dump","(depth)","<p>marshalling is not allowed\n"],["align","DL::PackInfo","DL/PackInfo.html#method-c-align","(addr, align)",""],["assign_names","DL::CStructEntity","DL/CStructEntity.html#method-i-assign_names","(members)",""],["bind","DL::Function","DL/Function.html#method-i-bind","(&block)",""],["bind","DL::Importer","DL/Importer.html#method-i-bind","(signature, *opts, &blk)",""],["bind_at_call","DL::CarriedFunction","DL/CarriedFunction.html#method-i-bind_at_call","(&block)",""],["bind_at_call","DL::Function","DL/Function.html#method-i-bind_at_call","(&block)",""],["bind_at_call","DL::TempFunction","DL/TempFunction.html#method-i-bind_at_call","(&block)",""],["bind_function","DL::Importer","DL/Importer.html#method-i-bind_function","(name, ctype, argtype, call_type = nil, &block)",""],["bound?","DL::Function","DL/Function.html#method-i-bound-3F","()",""],["bufferSize","Win32::SSPI::SecurityBuffer","Win32/SSPI/SecurityBuffer.html#method-i-bufferSize","()",""],["bufferType","Win32::SSPI::SecurityBuffer","Win32/SSPI/SecurityBuffer.html#method-i-bufferType","()",""],["call","DL::CFunc","DL/CFunc.html#method-i-call","(p1)","<p>Calls the function pointer passing in <code>ary</code> as values to the\nunderlying C function.  The return value depends …\n"],["call","DL::Function","DL/Function.html#method-i-call","(*args, &block)",""],["call","Win32API","Win32API.html#method-i-call","(*args)",""],["calltype","DL::CFunc","DL/CFunc.html#method-i-calltype","()","<p>Get the call type of this function.\n"],["calltype=","DL::CFunc","DL/CFunc.html#method-i-calltype-3D","(p1)","<p>Set the call type for this function.\n"],["check","Win32::Registry::API","Win32/Registry/API.html#method-i-check","(result)",""],["class","Win32::Registry::PredefinedKey","Win32/Registry/PredefinedKey.html#method-i-class","()","<p>Fake #class method for Registry#open, Registry#create\n"],["close","DL::Handle","DL/Handle.html#method-i-close","()","<p>Close this DL::Handle.  Calling close more than once will raise a\nDL::DLError exception.\n"],["close","Win32::Registry","Win32/Registry.html#method-i-close","()","<p>Close key.\n<p>After close, most method raise an error.\n"],["close","Win32::Registry::PredefinedKey","Win32/Registry/PredefinedKey.html#method-i-close","()","<p>Predefined keys cannot be closed\n"],["close_enabled?","DL::Handle","DL/Handle.html#method-i-close_enabled-3F","()","<p>Returns <code>true</code> if dlclose() will be called when this DL::Handle\nis garbage collected.\n"],["complete_authentication","Win32::SSPI::NegotiateAuth","Win32/SSPI/NegotiateAuth.html#method-i-complete_authentication","(token)","<p>Takes a token and gets the next token in the Negotiate authentication\nchain. Token can be Base64 encoded …\n"],["create","DL::CStructBuilder","DL/CStructBuilder.html#method-c-create","(klass, types, members)",""],["create","Win32::Registry","Win32/Registry.html#method-i-create","(subkey, desired = KEY_ALL_ACCESS, opt = REG_OPTION_RESERVED, &blk)","<p>Same as Win32::Registry.create (self, subkey, desired, opt)\n"],["create","Win32::Registry","Win32/Registry.html#method-c-create","(hkey, subkey, desired = KEY_ALL_ACCESS, opt = REG_OPTION_RESERVED)","<p>— Registry.create(key, subkey, desired = KEY_ALL_ACCESS, opt =\nREG_OPTION_RESERVED)\n<p>— Registry.create …\n"],["create_carried_function","DL::Importer","DL/Importer.html#method-i-create_carried_function","(name, ctype, argtype, call_type = nil, n = 0)",""],["create_carrier","DL::CarriedFunction","DL/CarriedFunction.html#method-i-create_carrier","(data)",""],["create_temp_function","DL::Importer","DL/Importer.html#method-i-create_temp_function","(name, ctype, argtype, call_type = nil)",""],["create_value","DL::Importer","DL/Importer.html#method-i-create_value","(ty, val=nil)",""],["created?","Win32::Registry","Win32/Registry.html#method-i-created-3F","()","<p>Returns if key is created ((<strong>newly</strong>)). (see Registry.create)\n– basically you call create then when you …\n"],["ctype","DL::CFunc","DL/CFunc.html#method-i-ctype","()","<p>Get the C function return value type.  See DL for a list of constants\ncorresponding to this method’s …\n"],["ctype=","DL::CFunc","DL/CFunc.html#method-i-ctype-3D","(p1)","<p>Set the C function return value type to <code>type</code>.\n"],["delete","Win32::Registry","Win32/Registry.html#method-i-delete","(name)",""],["delete_key","Win32::Registry","Win32/Registry.html#method-i-delete_key","(name, recursive = false)","<p>Delete a subkey named name and all its values.\n<p>If recursive is false, the subkey must not have subkeys. …\n"],["delete_value","Win32::Registry","Win32/Registry.html#method-i-delete_value","(name)","<p>Delete a registry value named name. We can not delete the `default’ value.\n"],["disable_close","DL::Handle","DL/Handle.html#method-i-disable_close","()","<p>Disable a call to dlclose() when this DL::Handle is garbage collected.\n"],["dlload","DL::Importer","DL/Importer.html#method-i-dlload","(*libs)",""],["dlopen","DL","DL.html#method-c-dlopen","(*args)",""],["dlunwrap","DL","DL.html#method-c-dlunwrap","(p1)",""],["dlwrap","DL","DL.html#method-c-dlwrap","(p1)",""],["each","Win32::Registry","Win32/Registry.html#method-i-each","()",""],["each_key","Win32::Registry","Win32/Registry.html#method-i-each_key","()","<p>Enumerate subkeys.\n<p>subkey is String which contains name of subkey. wtime is last write time as\nFILETIME …\n"],["each_value","Win32::Registry","Win32/Registry.html#method-i-each_value","()","<p>Enumerate values.\n"],["enable_close","DL::Handle","DL/Handle.html#method-i-enable_close","()","<p>Enable a call to dlclose() when this DL::Handle is garbage collected.\n"],["entity_class","DL::CStruct","DL/CStruct.html#method-c-entity_class","()",""],["entity_class","DL::CUnion","DL/CUnion.html#method-c-entity_class","()",""],["eql?","DL::CPtr","DL/CPtr.html#method-i-eql-3F","(p1)","<p>Returns true if <code>other</code> wraps the same pointer, otherwise\nreturns false.\n"],["expand_environ","Win32::Registry","Win32/Registry.html#method-c-expand_environ","(str)","<p>Replace %w+% into the environment value of what is contained between the\n%‘s This method is used for …\n"],["extern","DL::Importer","DL/Importer.html#method-i-extern","(signature, *opts)",""],["fiddle?","DL","DL.html#method-c-fiddle-3F","()",""],["flush","Win32::Registry","Win32/Registry.html#method-i-flush","()","<p>Write all the attributes into the registry file.\n"],["foreach_proc_entry","Object","Object.html#method-i-foreach_proc_entry","()",""],["free","DL","DL.html#method-c-free","(p1)","<p>Free the memory at address <code>addr</code>\n"],["free","DL::CPtr","DL/CPtr.html#method-i-free","()","<p>Get the free function for this pointer.  Returns  DL::CFunc or nil.\n"],["free=","DL::CPtr","DL/CPtr.html#method-i-free-3D","(p1)","<p>Set the free function for this pointer to the DL::CFunc in\n<code>function</code>.\n"],["func_name","Object","Object.html#method-i-func_name","(ty, argc, n, calltype)",""],["gen_callback_file","Object","Object.html#method-i-gen_callback_file","(ty)",""],["gen_push_addr_ary","Object","Object.html#method-i-gen_push_addr_ary","(ty, aryname, calltype)",""],["gen_push_proc_ary","Object","Object.html#method-i-gen_push_proc_ary","(ty, aryname)",""],["gencallback","Object","Object.html#method-i-gencallback","(ty, calltype, proc_entry, argc, n)",""],["get_hosts_path","Win32::Resolv","Win32/Resolv.html#method-c-get_hosts_path","()",""],["get_initial_token","Win32::SSPI::NegotiateAuth","Win32/SSPI/NegotiateAuth.html#method-i-get_initial_token","()","<p>Gets the initial Negotiate token. Returns it as a base64 encoded string\nsuitable for use in HTTP. Can …\n"],["get_resolv_info","Win32::Resolv","Win32/Resolv.html#method-c-get_resolv_info","()",""],["handler","DL::Importer","DL/Importer.html#method-i-handler","()",""],["handlers","DL::CompositeHandler","DL/CompositeHandler.html#method-i-handlers","()",""],["import_function","DL::Importer","DL/Importer.html#method-i-import_function","(name, ctype, argtype, call_type = nil)",""],["import_symbol","DL::Importer","DL/Importer.html#method-i-import_symbol","(name)",""],["import_value","DL::Importer","DL/Importer.html#method-i-import_value","(ty, addr)",""],["info","Win32::Registry","Win32/Registry.html#method-i-info","()","<p>Returns key information as Array of: :num_keys\n\n<pre>The number of subkeys.</pre>\n<p>:max_key_length\n"],["inspect","DL::CFunc","DL/CFunc.html#method-i-inspect","()","<p>Returns a string formatted with an easily readable representation of the\ninternal state of the DL::CFunc …\n"],["inspect","DL::CPtr","DL/CPtr.html#method-i-inspect","()","<p>Returns a string formatted with an easily readable representation of the\ninternal state of the DL::CPtr …\n"],["inspect","Win32::Registry","Win32/Registry.html#method-i-inspect","()",""],["keys","Win32::Registry","Win32/Registry.html#method-i-keys","()","<p>return keys as an array\n"],["last_error","DL::CFunc","DL/CFunc.html#method-c-last_error","()","<p>Returns the last error for the current executing thread\n"],["lower","Win32::SSPI::SecurityHandle","Win32/SSPI/SecurityHandle.html#method-i-lower","()",""],["malloc","DL","DL.html#method-c-malloc","(p1)","<p>Allocate <code>size</code> bytes of memory and return the integer memory\naddress for the allocated memory.\n"],["malloc","DL::CPtr","DL/CPtr.html#method-c-malloc","(p1, p2 = v2)","<p>Allocate <code>size</code> bytes of memory and associate it with an\noptional <code>freefunc</code> that will be called when the …\n"],["malloc","DL::CStructEntity","DL/CStructEntity.html#method-c-malloc","(types, func = nil)",""],["malloc","DL::CUnionEntity","DL/CUnionEntity.html#method-c-malloc","(types, func=nil)",""],["name","DL::CFunc","DL/CFunc.html#method-i-name","()","<p>Get the name of this function\n"],["name","DL::Function","DL/Function.html#method-i-name","()",""],["name","Win32::Registry","Win32/Registry.html#method-i-name","()","<p>Full path of key such as ‘HKEY_CURRENT_USERSOFTWAREfoobar’.\n"],["new","DL::CFunc","DL/CFunc.html#method-c-new","(p1, p2 = v2, p3 = v3, p4 = v4)","<p>Create a new function that points to <code>address</code> with an optional\nreturn type of <code>type</code>, a name of <code>name</code> and …\n"],["new","DL::CPtr","DL/CPtr.html#method-c-new","(p1, p2 = v2, p3 = v3)","<p>Create a new pointer to <code>address</code> with an optional\n<code>size</code> and <code>freefunc</code>. <code>freefunc</code> will be\ncalled when the …\n"],["new","DL::CStructEntity","DL/CStructEntity.html#method-c-new","(addr, types, func = nil)",""],["new","DL::CarriedFunction","DL/CarriedFunction.html#method-c-new","(cfunc, argtypes, n)",""],["new","DL::CompositeHandler","DL/CompositeHandler.html#method-c-new","(handlers)",""],["new","DL::Function","DL/Function.html#method-c-new","(cfunc, argtypes, abi = nil, &block)",""],["new","DL::Handle","DL/Handle.html#method-c-new","(p1 = v1, p2 = v2)","<p>Create a new handler that opens library named <code>lib</code> with\n<code>flags</code>.  If no library is specified, RTLD_DEFAULT …\n"],["new","DL::Packer","DL/Packer.html#method-c-new","(types)",""],["new","DL::Stack","DL/Stack.html#method-c-new","(types)",""],["new","Win32::Registry","Win32/Registry.html#method-c-new","(hkey, parent, keyname, disposition)","<p>initialize\n"],["new","Win32::Registry::Error","Win32/Registry/Error.html#method-c-new","(code)",""],["new","Win32::Registry::PredefinedKey","Win32/Registry/PredefinedKey.html#method-c-new","(hkey, keyname)",""],["new","Win32::SSPI::Identity","Win32/SSPI/Identity.html#method-c-new","(user = nil, domain = nil, password = nil)",""],["new","Win32::SSPI::NegotiateAuth","Win32/SSPI/NegotiateAuth.html#method-c-new","(user = nil, domain = nil)","<p>Creates a new instance ready for authentication as the given user in the\ngiven domain. Defaults to current …\n"],["new","Win32::SSPI::SSPIResult","Win32/SSPI/SSPIResult.html#method-c-new","(value)",""],["new","Win32::SSPI::SecurityBuffer","Win32/SSPI/SecurityBuffer.html#method-c-new","(buffer = nil)",""],["new","Win32API","Win32API.html#method-c-new","(dllname, func, import, export = \"0\", calltype = :stdcall)",""],["null?","DL::CPtr","DL/CPtr.html#method-i-null-3F","()","<p>Returns true if this is a null pointer.\n"],["ok?","Win32::SSPI::SSPIResult","Win32/SSPI/SSPIResult.html#method-i-ok-3F","()",""],["open","Win32::Registry","Win32/Registry.html#method-c-open","(hkey, subkey, desired = KEY_READ, opt = REG_OPTION_RESERVED)","<p>— Registry.open(key, subkey, desired = KEY_READ, opt = REG_OPTION_RESERVED)\n<p>— Registry.open(key, subkey, …\n"],["open","Win32::Registry","Win32/Registry.html#method-i-open","(subkey, desired = KEY_READ, opt = REG_OPTION_RESERVED, &blk)","<p>Same as Win32::Registry.open (self, subkey, desired, opt)\n"],["open?","Win32::Registry","Win32/Registry.html#method-i-open-3F","()","<p>Returns if key is not closed.\n"],["pack","DL::Packer","DL/Packer.html#method-i-pack","(ary)",""],["pack","DL::Stack","DL/Stack.html#method-i-pack","(ary)",""],["packdw","Win32::Registry::API","Win32/Registry/API.html#method-i-packdw","(dw)",""],["packqw","Win32::Registry::API","Win32/Registry/API.html#method-i-packqw","(qw)",""],["parse_ctype","DL::CParser","DL/CParser.html#method-i-parse_ctype","(ty, tymap=nil)",""],["parse_signature","DL::CParser","DL/CParser.html#method-i-parse_signature","(signature, tymap=nil)",""],["parse_struct_signature","DL::CParser","DL/CParser.html#method-i-parse_struct_signature","(signature, tymap=nil)",""],["proxy_auth_get","Win32::SSPI::NegotiateAuth","Win32/SSPI/NegotiateAuth.html#method-c-proxy_auth_get","(http, path, user = nil, domain = nil)","<p>Given a connection and a request path, performs authentication as the\ncurrent user and returns the response …\n"],["ptr","DL::CFunc","DL/CFunc.html#method-i-ptr","()","<p>Get the underlying function pointer as a DL::CPtr object.\n"],["ptr","DL::CPtr","DL/CPtr.html#method-i-ptr","()","<p>Returns a DL::CPtr that is a dereferenced pointer for this DL::CPtr.\nAnalogous to the star operator in …\n"],["ptr=","DL::CFunc","DL/CFunc.html#method-i-ptr-3D","(p1)","<p>Set the underlying function pointer to a DL::CPtr named\n<code>pointer</code>.\n"],["read","Win32::Registry","Win32/Registry.html#method-i-read","(name, *rtype)","<p>Read a registry value named name and return array of [ type, data ]. When\nname is nil, the `default’ …\n"],["read_bin","Win32::Registry","Win32/Registry.html#method-i-read_bin","(name)","<p>Read a REG_SZ(read_s), REG_DWORD(read_i), or REG_BINARY(read_bin) registry\nvalue named name.\n<p>If the values …\n"],["read_i","Win32::Registry","Win32/Registry.html#method-i-read_i","(name)","<p>Read a REG_SZ(read_s), REG_DWORD(read_i), or REG_BINARY(read_bin) registry\nvalue named name.\n<p>If the values …\n"],["read_s","Win32::Registry","Win32/Registry.html#method-i-read_s","(name)","<p>Read a REG_SZ(read_s), REG_DWORD(read_i), or REG_BINARY(read_bin) registry\nvalue named name.\n<p>If the values …\n"],["read_s_expand","Win32::Registry","Win32/Registry.html#method-i-read_s_expand","(name)","<p>Read a REG_SZ or REG_EXPAND_SZ registry value named name.\n<p>If the value type is REG_EXPAND_SZ, environment …\n"],["realloc","DL","DL.html#method-c-realloc","(p1, p2)","<p>Change the size of the memory allocated at the memory location\n<code>addr</code> to <code>size</code> bytes.  Returns the memory …\n"],["ref","DL::CPtr","DL/CPtr.html#method-i-ref","()","<p>Returns a DL::CPtr that is a reference pointer for this DL::CPtr. Analogous\nto the ampersand operator …\n"],["remove_callback","DL","DL.html#method-i-remove_callback","(addr, ctype = nil)",""],["remove_callback_internal","DL","DL.html#method-i-remove_callback_internal","(proc_entry, addr_entry, addr, ctype = nil)",""],["remove_cdecl_callback","DL","DL.html#method-i-remove_cdecl_callback","(addr, ctype = nil)",""],["remove_stdcall_callback","DL","DL.html#method-i-remove_stdcall_callback","(addr, ctype = nil)",""],["set_callback","DL","DL.html#method-i-set_callback","(ty, argc, &cbp)",""],["set_callback_internal","DL","DL.html#method-i-set_callback_internal","(proc_entry, addr_entry, argc, ty, abi = nil, &cbp)",""],["set_cdecl_callback","DL","DL.html#method-i-set_cdecl_callback","(ty, argc, &cbp)",""],["set_ctypes","DL::CStructEntity","DL/CStructEntity.html#method-i-set_ctypes","(types)",""],["set_ctypes","DL::CUnionEntity","DL/CUnionEntity.html#method-i-set_ctypes","(types)",""],["set_stdcall_callback","DL","DL.html#method-i-set_stdcall_callback","(ty, argc, &cbp)",""],["signed_value","DL::ValueUtil","DL/ValueUtil.html#method-i-signed_value","(val, ty)",""],["size","DL::CPtr","DL/CPtr.html#method-i-size","()","<p>Get the size of this pointer.\n"],["size","DL::CStructEntity","DL/CStructEntity.html#method-c-size","(types)",""],["size","DL::CUnionEntity","DL/CUnionEntity.html#method-c-size","(types)",""],["size","DL::Packer","DL/Packer.html#method-i-size","()",""],["size","DL::Stack","DL/Stack.html#method-i-size","()",""],["size=","DL::CPtr","DL/CPtr.html#method-i-size-3D","(p1)","<p>Set the size of this pointer to <code>size</code>\n"],["sizeof","DL::Importer","DL/Importer.html#method-i-sizeof","(ty)",""],["struct","DL::Importer","DL/Importer.html#method-i-struct","(signature)",""],["sym","DL::CompositeHandler","DL/CompositeHandler.html#method-i-sym","(symbol)",""],["sym","DL::Handle","DL/Handle.html#method-i-sym","(p1)","\n<pre>Document-method: []</pre>\n<p>Get the address as an Integer for the function named <code>name</code>.\n"],["sym","DL::Handle","DL/Handle.html#method-c-sym","(p1)","\n<pre>Document-method: []</pre>\n<p>Get the address as an Integer for the function named <code>name</code>.\n"],["time2wtime","Win32::Registry","Win32/Registry.html#method-c-time2wtime","(time)","<p>Convert Time object or Integer object into 64-bit FILETIME.\n"],["to_i","DL::CFunc","DL/CFunc.html#method-i-to_i","()","<p>Returns the memory location of this function pointer as an integer.\n"],["to_i","DL::CPtr","DL/CPtr.html#method-i-to_i","()","<p>Returns the integer memory location of this DL::CPtr.\n"],["to_i","DL::Function","DL/Function.html#method-i-to_i","()",""],["to_i","DL::Handle","DL/Handle.html#method-i-to_i","()","<p>Returns the memory address for this handle.\n"],["to_int","DL::CPtr","DL/CPtr.html#method-i-to_int","()","<p>Returns the integer memory location of this DL::CPtr.\n"],["to_p","Win32::SSPI::Identity","Win32/SSPI/Identity.html#method-i-to_p","()",""],["to_p","Win32::SSPI::SecurityBuffer","Win32/SSPI/SecurityBuffer.html#method-i-to_p","()",""],["to_p","Win32::SSPI::SecurityHandle","Win32/SSPI/SecurityHandle.html#method-i-to_p","()",""],["to_p","Win32::SSPI::TimeStamp","Win32/SSPI/TimeStamp.html#method-i-to_p","()",""],["to_ptr","DL::CPtr","DL/CPtr.html#method-c-to_ptr","(p1)","<p>Get the underlying pointer for ruby object <code>val</code> and return it\nas a DL::CPtr object.\n"],["to_s","DL::CFunc","DL/CFunc.html#method-i-to_s","()","<p>Returns a string formatted with an easily readable representation of the\ninternal state of the DL::CFunc …\n"],["to_s","DL::CPtr","DL/CPtr.html#method-i-to_s","(p1 = v1)","<p>Returns the pointer contents as a string.  When called with no arguments,\nthis method will return the …\n"],["to_s","DL::CStructEntity","DL/CStructEntity.html#method-i-to_s","()",""],["to_s","Win32::SSPI::SSPIResult","Win32/SSPI/SSPIResult.html#method-i-to_s","()",""],["to_str","DL::CPtr","DL/CPtr.html#method-i-to_str","(p1 = v1)","<p>Returns the pointer contents as a string.  When called with no arguments,\nthis method will return the …\n"],["to_value","DL::CPtr","DL/CPtr.html#method-i-to_value","()","<p>Cast this CPtr to a ruby object.\n"],["token","Win32::SSPI::SecurityBuffer","Win32/SSPI/SecurityBuffer.html#method-i-token","()",""],["type2name","Win32::Registry","Win32/Registry.html#method-c-type2name","(type)","<p>Convert registry type value to readable string.\n"],["typealias","DL::Importer","DL/Importer.html#method-i-typealias","(alias_type, orig_type)",""],["types","DL::Stack","DL/Stack.html#method-i-types","()",""],["unbind","DL::Function","DL/Function.html#method-i-unbind","()",""],["unbind_at_call","DL::Function","DL/Function.html#method-i-unbind_at_call","()",""],["unbind_at_call","DL::TempFunction","DL/TempFunction.html#method-i-unbind_at_call","()",""],["union","DL::Importer","DL/Importer.html#method-i-union","(signature)",""],["unpack","DL::Packer","DL/Packer.html#method-i-unpack","(ary)",""],["unpack","DL::Stack","DL/Stack.html#method-i-unpack","(ary)",""],["unpackdw","Win32::Registry::API","Win32/Registry/API.html#method-i-unpackdw","(dw)",""],["unpackqw","Win32::Registry::API","Win32/Registry/API.html#method-i-unpackqw","(qw)",""],["unsigned_value","DL::ValueUtil","DL/ValueUtil.html#method-i-unsigned_value","(val, ty)",""],["upper","Win32::SSPI::SecurityHandle","Win32/SSPI/SecurityHandle.html#method-i-upper","()",""],["value","DL::Importer","DL/Importer.html#method-i-value","(ty, val=nil)",""],["win32_last_error","DL::CFunc","DL/CFunc.html#method-c-win32_last_error","()","<p>Returns the last win32 error for the current executing thread\n"],["wrap_arg","DL::ValueUtil","DL/ValueUtil.html#method-i-wrap_arg","(arg, ty, funcs = [], &block)",""],["wrap_args","DL::ValueUtil","DL/ValueUtil.html#method-i-wrap_args","(args, tys, funcs, &block)",""],["wrap_result","DL::Function","DL/Function.html#method-i-wrap_result","(r)",""],["write","Win32::Registry","Win32/Registry.html#method-i-write","(name, type, data)","<p>Write data to a registry value named name. When name is nil, write to the\n`default’ value.\n<p>type is type …\n"],["write_bin","Win32::Registry","Win32/Registry.html#method-i-write_bin","(name, value)","<p>Write value to a registry value named name.\n<p>The value type is REG_SZ(write_s), REG_DWORD(write_i), or …\n"],["write_i","Win32::Registry","Win32/Registry.html#method-i-write_i","(name, value)","<p>Write value to a registry value named name.\n<p>The value type is REG_SZ(write_s), REG_DWORD(write_i), or …\n"],["write_s","Win32::Registry","Win32/Registry.html#method-i-write_s","(name, value)","<p>Write value to a registry value named name.\n<p>The value type is REG_SZ(write_s), REG_DWORD(write_i), or …\n"],["wtime2time","Win32::Registry","Win32/Registry.html#method-c-wtime2time","(wtime)","<p>Convert 64-bit FILETIME integer into Time object.\n"]]}}