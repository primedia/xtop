var search_data = {"index":{"searchIndex":["matrix","eigenvaluedecomposition","lupdecomposition","vector","zerovectorerror","*()","*()","**()","+()","+()","-()","-()","/()","/()","==()","==()","i()","[]()","[]()","[]()","[]()","build()","clone()","clone()","coerce()","coerce()","collect()","collect()","collect2()","column()","column_vector()","column_vectors()","columns()","component()","component()","conj()","conjugate()","covector()","d()","det()","det()","det_e()","determinant()","determinant()","determinant_e()","diagonal()","diagonal?()","each()","each()","each2()","each_with_index()","eigen()","eigensystem()","eigenvalue_matrix()","eigenvalues()","eigenvector_matrix()","eigenvector_matrix_inv()","eigenvectors()","element()","element()","elements()","elements_to_f()","elements_to_f()","elements_to_i()","elements_to_i()","elements_to_r()","elements_to_r()","empty()","empty?()","eql?()","eql?()","find_index()","hash()","hash()","hermitian?()","identity()","imag()","imaginary()","index()","inner_product()","inspect()","inspect()","inv()","inverse()","l()","lower_triangular?()","lup()","lup_decomposition()","magnitude()","map()","map()","map2()","minor()","new()","new()","new()","new()","norm()","normal?()","normalize()","orthogonal?()","p()","permutation?()","r()","rank()","rank_e()","real()","real?()","rect()","rectangular()","regular?()","round()","row()","row_size()","row_vector()","row_vectors()","rows()","scalar()","singular?()","singular?()","size()","solve()","square?()","symmetric?()","t()","to_a()","to_a()","to_a()","to_a()","to_ary()","to_ary()","to_s()","to_s()","tr()","trace()","transpose()","u()","unit()","unitary?()","upper_triangular?()","v()","v_inv()","zero()","zero?()"],"longSearchIndex":["matrix","matrix::eigenvaluedecomposition","matrix::lupdecomposition","vector","vector::zerovectorerror","matrix#*()","vector#*()","matrix#**()","matrix#+()","vector#+()","matrix#-()","vector#-()","matrix#/()","vector#/()","matrix#==()","vector#==()","matrix::i()","matrix#[]()","matrix::[]()","vector#[]()","vector::[]()","matrix::build()","matrix#clone()","vector#clone()","matrix#coerce()","vector#coerce()","matrix#collect()","vector#collect()","vector#collect2()","matrix#column()","matrix::column_vector()","matrix#column_vectors()","matrix::columns()","matrix#component()","vector#component()","matrix#conj()","matrix#conjugate()","vector#covector()","matrix::eigenvaluedecomposition#d()","matrix#det()","matrix::lupdecomposition#det()","matrix#det_e()","matrix#determinant()","matrix::lupdecomposition#determinant()","matrix#determinant_e()","matrix::diagonal()","matrix#diagonal?()","matrix#each()","vector#each()","vector#each2()","matrix#each_with_index()","matrix#eigen()","matrix#eigensystem()","matrix::eigenvaluedecomposition#eigenvalue_matrix()","matrix::eigenvaluedecomposition#eigenvalues()","matrix::eigenvaluedecomposition#eigenvector_matrix()","matrix::eigenvaluedecomposition#eigenvector_matrix_inv()","matrix::eigenvaluedecomposition#eigenvectors()","matrix#element()","vector#element()","vector::elements()","matrix#elements_to_f()","vector#elements_to_f()","matrix#elements_to_i()","vector#elements_to_i()","matrix#elements_to_r()","vector#elements_to_r()","matrix::empty()","matrix#empty?()","matrix#eql?()","vector#eql?()","matrix#find_index()","matrix#hash()","vector#hash()","matrix#hermitian?()","matrix::identity()","matrix#imag()","matrix#imaginary()","matrix#index()","vector#inner_product()","matrix#inspect()","vector#inspect()","matrix#inv()","matrix#inverse()","matrix::lupdecomposition#l()","matrix#lower_triangular?()","matrix#lup()","matrix#lup_decomposition()","vector#magnitude()","matrix#map()","vector#map()","vector#map2()","matrix#minor()","matrix::new()","matrix::eigenvaluedecomposition::new()","matrix::lupdecomposition::new()","vector::new()","vector#norm()","matrix#normal?()","vector#normalize()","matrix#orthogonal?()","matrix::lupdecomposition#p()","matrix#permutation?()","vector#r()","matrix#rank()","matrix#rank_e()","matrix#real()","matrix#real?()","matrix#rect()","matrix#rectangular()","matrix#regular?()","matrix#round()","matrix#row()","matrix#row_size()","matrix::row_vector()","matrix#row_vectors()","matrix::rows()","matrix::scalar()","matrix#singular?()","matrix::lupdecomposition#singular?()","vector#size()","matrix::lupdecomposition#solve()","matrix#square?()","matrix#symmetric?()","matrix#t()","matrix#to_a()","matrix::eigenvaluedecomposition#to_a()","matrix::lupdecomposition#to_a()","vector#to_a()","matrix::eigenvaluedecomposition#to_ary()","matrix::lupdecomposition#to_ary()","matrix#to_s()","vector#to_s()","matrix#tr()","matrix#trace()","matrix#transpose()","matrix::lupdecomposition#u()","matrix::unit()","matrix#unitary?()","matrix#upper_triangular?()","matrix::eigenvaluedecomposition#v()","matrix::eigenvaluedecomposition#v_inv()","matrix::zero()","matrix#zero?()"],"info":[["Matrix","","Matrix.html","","<p>The <code>Matrix</code> class represents a mathematical matrix. It provides\nmethods for creating matrices, operating …\n"],["Matrix::EigenvalueDecomposition","","Matrix/EigenvalueDecomposition.html","","<p>Eigenvalues and eigenvectors of a real matrix.\n<p>Computes the eigenvalues and eigenvectors of a matrix  …\n"],["Matrix::LUPDecomposition","","Matrix/LUPDecomposition.html","","<p>For an m-by-n matrix A with m &gt;= n, the LU decomposition is an m-by-n\nunit lower triangular matrix …\n"],["Vector","","Vector.html","","<p>The <code>Vector</code> class represents a mathematical vector, which is\nuseful in its own right, and also constitutes …\n"],["Vector::ZeroVectorError","","Vector/ZeroVectorError.html","",""],["*","Matrix","Matrix.html#method-i-2A","(m)","<p>Matrix multiplication.\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Matrix</span>[[<span class=\"ruby-value\">2</span>,<span class=\"ruby-value\">4</span>], [<span class=\"ruby-value\">6</span>,<span class=\"ruby-value\">8</span>]] <span class=\"ruby-operator\">*</span> <span class=\"ruby-constant\">Matrix</span>.<span class=\"ruby-identifier\">identity</span>(<span class=\"ruby-value\">2</span>)\n  =<span class=\"ruby-operator\">&gt;</span> <span class=\"ruby-value\">2</span> <span class=\"ruby-value\">4</span>\n     <span class=\"ruby-value\">6</span> <span class=\"ruby-value\">8</span>\n</pre>\n"],["*","Vector","Vector.html#method-i-2A","(x)","<p>Multiplies the vector by <code>x</code>, where <code>x</code> is a number\nor another vector.\n"],["**","Matrix","Matrix.html#method-i-2A-2A","(other)","<p>Matrix exponentiation. Equivalent to multiplying the matrix by itself N\ntimes. Non integer exponents …\n"],["+","Matrix","Matrix.html#method-i-2B","(m)","<p>Matrix addition.\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Matrix</span>.<span class=\"ruby-identifier\">scalar</span>(<span class=\"ruby-value\">2</span>,<span class=\"ruby-value\">5</span>) <span class=\"ruby-operator\">+</span> <span class=\"ruby-constant\">Matrix</span>[[<span class=\"ruby-value\">1</span>,<span class=\"ruby-value\">0</span>], [<span class=\"ruby-value\">-4</span>,<span class=\"ruby-value\">7</span>]]\n  =<span class=\"ruby-operator\">&gt;</span>  <span class=\"ruby-value\">6</span>  <span class=\"ruby-value\">0</span>\n     <span class=\"ruby-value\">-4</span> <span class=\"ruby-value\">12</span>\n</pre>\n"],["+","Vector","Vector.html#method-i-2B","(v)","<p>Vector addition.\n"],["-","Matrix","Matrix.html#method-i-2D","(m)","<p>Matrix subtraction.\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Matrix</span>[[<span class=\"ruby-value\">1</span>,<span class=\"ruby-value\">5</span>], [<span class=\"ruby-value\">4</span>,<span class=\"ruby-value\">2</span>]] <span class=\"ruby-operator\">-</span> <span class=\"ruby-constant\">Matrix</span>[[<span class=\"ruby-value\">9</span>,<span class=\"ruby-value\">3</span>], [<span class=\"ruby-value\">-4</span>,<span class=\"ruby-value\">1</span>]]\n  =<span class=\"ruby-operator\">&gt;</span> <span class=\"ruby-value\">-8</span>  <span class=\"ruby-value\">2</span>\n      <span class=\"ruby-value\">8</span>  <span class=\"ruby-value\">1</span>\n</pre>\n"],["-","Vector","Vector.html#method-i-2D","(v)","<p>Vector subtraction.\n"],["/","Matrix","Matrix.html#method-i-2F","(other)","<p>Matrix division (multiplication by the inverse).\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Matrix</span>[[<span class=\"ruby-value\">7</span>,<span class=\"ruby-value\">6</span>], [<span class=\"ruby-value\">3</span>,<span class=\"ruby-value\">9</span>]] <span class=\"ruby-operator\">/</span> <span class=\"ruby-constant\">Matrix</span>[[<span class=\"ruby-value\">2</span>,<span class=\"ruby-value\">9</span>], [<span class=\"ruby-value\">3</span>,<span class=\"ruby-value\">1</span>]]\n  =<span class=\"ruby-operator\">&gt;</span> <span class=\"ruby-value\">-7</span>  <span class=\"ruby-operator\">...</span>\n</pre>\n"],["/","Vector","Vector.html#method-i-2F","(x)","<p>Vector division.\n"],["==","Matrix","Matrix.html#method-i-3D-3D","(other)","<p>Returns <code>true</code> if and only if the two matrices contain equal\nelements.\n"],["==","Vector","Vector.html#method-i-3D-3D","(other)","<p>Returns <code>true</code> iff the two vectors have the same elements in the\nsame order.\n"],["I","Matrix","Matrix.html#method-c-I","(n)",""],["[]","Matrix","Matrix.html#method-i-5B-5D","(i, j)","<p>Returns element (<code>i</code>,<code>j</code>) of the matrix.  That is:\nrow <code>i</code>, column <code>j</code>.\n"],["[]","Matrix","Matrix.html#method-c-5B-5D","(*rows)","<p>Creates a matrix where each argument is a row.\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Matrix</span>[ [<span class=\"ruby-value\">25</span>, <span class=\"ruby-value\">93</span>], [<span class=\"ruby-value\">-1</span>, <span class=\"ruby-value\">66</span>] ]\n   =<span class=\"ruby-operator\">&gt;</span>  <span class=\"ruby-value\">25</span> <span class=\"ruby-value\">93</span>\n       <span class=\"ruby-value\">-1</span> <span class=\"ruby-value\">66</span>\n</pre>\n"],["[]","Vector","Vector.html#method-i-5B-5D","(i)","<p>Returns element number <code>i</code> (starting at zero) of the vector.\n"],["[]","Vector","Vector.html#method-c-5B-5D","(*array)","<p>Creates a Vector from a list of elements.\n\n<pre>Vector[7, 4, ...]</pre>\n"],["build","Matrix","Matrix.html#method-c-build","(row_size, column_size = row_size)","<p>Creates a matrix of size <code>row_size</code> x <code>column_size</code>.\nIt fills the values by calling the given block, passing …\n"],["clone","Matrix","Matrix.html#method-i-clone","()","<p>Returns a clone of the matrix, so that the contents of each do not\nreference identical objects. There …\n"],["clone","Vector","Vector.html#method-i-clone","()","<p>Return a copy of the vector.\n"],["coerce","Matrix","Matrix.html#method-i-coerce","(other)","<p>The coerce method provides support for Ruby type coercion. This coercion\nmechanism is used by Ruby to …\n"],["coerce","Vector","Vector.html#method-i-coerce","(other)","<p>The coerce method provides support for Ruby type coercion. This coercion\nmechanism is used by Ruby to …\n"],["collect","Matrix","Matrix.html#method-i-collect","()","<p>Returns a matrix that is the result of iteration of the given block over\nall elements of the matrix. …\n"],["collect","Vector","Vector.html#method-i-collect","()","<p>Like Array#collect.\n"],["collect2","Vector","Vector.html#method-i-collect2","(v)","<p>Collects (as in Enumerable#collect) over the elements of this vector and\n<code>v</code> in conjunction.\n"],["column","Matrix","Matrix.html#method-i-column","(j)","<p>Returns column vector number <code>j</code> of the matrix as a Vector\n(starting at 0 like an array).  When a block …\n"],["column_vector","Matrix","Matrix.html#method-c-column_vector","(column)","<p>Creates a single-column matrix where the values of that column are as given\nin <code>column</code>.\n\n<pre>Matrix.column_vector([4,5,6]) ...</pre>\n"],["column_vectors","Matrix","Matrix.html#method-i-column_vectors","()","<p>Returns an array of the column vectors of the matrix.  See Vector.\n"],["columns","Matrix","Matrix.html#method-c-columns","(columns)","<p>Creates a matrix using <code>columns</code> as an array of column vectors.\n\n<pre>Matrix.columns([[25, 93], [-1, 66]])\n   ...</pre>\n"],["component","Matrix","Matrix.html#method-i-component","(i, j)",""],["component","Vector","Vector.html#method-i-component","(i)",""],["conj","Matrix","Matrix.html#method-i-conj","()",""],["conjugate","Matrix","Matrix.html#method-i-conjugate","()","<p>Returns the conjugate of the matrix.\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Matrix</span>[[<span class=\"ruby-constant\">Complex</span>(<span class=\"ruby-value\">1</span>,<span class=\"ruby-value\">2</span>), <span class=\"ruby-constant\">Complex</span>(<span class=\"ruby-value\">0</span>,<span class=\"ruby-value\">1</span>), <span class=\"ruby-value\">0</span>], [<span class=\"ruby-value\">1</span>, <span class=\"ruby-value\">2</span>, <span class=\"ruby-value\">3</span>]]\n  =<span class=\"ruby-operator\">&gt;</span> <span class=\"ruby-value\">1</span><span class=\"ruby-operator\">+</span><span class=\"ruby-value\">2</span><span class=\"ruby-identifier\">i</span>   <span class=\"ruby-identifier\">i</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["covector","Vector","Vector.html#method-i-covector","()","<p>Creates a single-row matrix from this vector.\n"],["d","Matrix::EigenvalueDecomposition","Matrix/EigenvalueDecomposition.html#method-i-d","()",""],["det","Matrix","Matrix.html#method-i-det","()",""],["det","Matrix::LUPDecomposition","Matrix/LUPDecomposition.html#method-i-det","()","<p>Returns the determinant of <code>A</code>, calculated efficiently from the\nfactorization.\n"],["det_e","Matrix","Matrix.html#method-i-det_e","()",""],["determinant","Matrix","Matrix.html#method-i-determinant","()","<p>Returns the determinant of the matrix.\n<p>Beware that using Float values can yield erroneous results because …\n"],["determinant","Matrix::LUPDecomposition","Matrix/LUPDecomposition.html#method-i-determinant","()",""],["determinant_e","Matrix","Matrix.html#method-i-determinant_e","()","<p>deprecated; use Matrix#determinant\n"],["diagonal","Matrix","Matrix.html#method-c-diagonal","(*values)","<p>Creates a matrix where the diagonal elements are composed of\n<code>values</code>.\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Matrix</span>.<span class=\"ruby-identifier\">diagonal</span>(<span class=\"ruby-value\">9</span>, <span class=\"ruby-value\">5</span>, <span class=\"ruby-value\">-3</span>)\n  =<span class=\"ruby-operator\">&gt;</span>  <span class=\"ruby-value\">9</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["diagonal?","Matrix","Matrix.html#method-i-diagonal-3F","()","<p>Returns <code>true</code> is this is a diagonal matrix. Raises an error if\nmatrix is not square.\n"],["each","Matrix","Matrix.html#method-i-each","(which = :all)","<p>Yields all elements of the matrix, starting with those of the first row, or\nreturns an Enumerator is …\n"],["each","Vector","Vector.html#method-i-each","(&block)","<p>Iterate over the elements of this vector\n"],["each2","Vector","Vector.html#method-i-each2","(v)","<p>Iterate over the elements of this vector and <code>v</code> in conjunction.\n"],["each_with_index","Matrix","Matrix.html#method-i-each_with_index","(which = :all)","<p>Same as #each, but the row index and column index in addition to the\nelement\n\n<pre>Matrix[ [1,2], [3,4] ].each_with_index ...</pre>\n"],["eigen","Matrix","Matrix.html#method-i-eigen","()",""],["eigensystem","Matrix","Matrix.html#method-i-eigensystem","()","<p>Returns the Eigensystem of the matrix; see\n<code>EigenvalueDecomposition</code>.\n\n<pre>m = Matrix[[1, 2], [3, 4]]\nv, d, v_inv ...</pre>\n"],["eigenvalue_matrix","Matrix::EigenvalueDecomposition","Matrix/EigenvalueDecomposition.html#method-i-eigenvalue_matrix","()","<p>Returns the block diagonal eigenvalue matrix <code>D</code>\n"],["eigenvalues","Matrix::EigenvalueDecomposition","Matrix/EigenvalueDecomposition.html#method-i-eigenvalues","()","<p>Returns the eigenvalues in an array\n"],["eigenvector_matrix","Matrix::EigenvalueDecomposition","Matrix/EigenvalueDecomposition.html#method-i-eigenvector_matrix","()","<p>Returns the eigenvector matrix <code>V</code>\n"],["eigenvector_matrix_inv","Matrix::EigenvalueDecomposition","Matrix/EigenvalueDecomposition.html#method-i-eigenvector_matrix_inv","()","<p>Returns the inverse of the eigenvector matrix <code>V</code>\n"],["eigenvectors","Matrix::EigenvalueDecomposition","Matrix/EigenvalueDecomposition.html#method-i-eigenvectors","()","<p>Returns an array of the eigenvectors\n"],["element","Matrix","Matrix.html#method-i-element","(i, j)",""],["element","Vector","Vector.html#method-i-element","(i)",""],["elements","Vector","Vector.html#method-c-elements","(array, copy = true)","<p>Creates a vector from an Array.  The optional second argument specifies\nwhether the array itself or a …\n"],["elements_to_f","Matrix","Matrix.html#method-i-elements_to_f","()",""],["elements_to_f","Vector","Vector.html#method-i-elements_to_f","()",""],["elements_to_i","Matrix","Matrix.html#method-i-elements_to_i","()",""],["elements_to_i","Vector","Vector.html#method-i-elements_to_i","()",""],["elements_to_r","Matrix","Matrix.html#method-i-elements_to_r","()",""],["elements_to_r","Vector","Vector.html#method-i-elements_to_r","()",""],["empty","Matrix","Matrix.html#method-c-empty","(row_size = 0, column_size = 0)","<p>Creates a empty matrix of <code>row_size</code> x <code>column_size</code>.\nAt least one of <code>row_size</code> or <code>column_size</code> must be\n0. …\n"],["empty?","Matrix","Matrix.html#method-i-empty-3F","()","<p>Returns <code>true</code> if this is an empty matrix, i.e. if the number of\nrows or the number of columns is 0.\n"],["eql?","Matrix","Matrix.html#method-i-eql-3F","(other)",""],["eql?","Vector","Vector.html#method-i-eql-3F","(other)",""],["find_index","Matrix","Matrix.html#method-i-find_index","(*args)",""],["hash","Matrix","Matrix.html#method-i-hash","()","<p>Returns a hash-code for the matrix.\n"],["hash","Vector","Vector.html#method-i-hash","()","<p>Return a hash-code for the vector.\n"],["hermitian?","Matrix","Matrix.html#method-i-hermitian-3F","()","<p>Returns <code>true</code> is this is an hermitian matrix. Raises an error\nif matrix is not square.\n"],["identity","Matrix","Matrix.html#method-c-identity","(n)","<p>Creates an <code>n</code> by <code>n</code> identity matrix.\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Matrix</span>.<span class=\"ruby-identifier\">identity</span>(<span class=\"ruby-value\">2</span>)\n  =<span class=\"ruby-operator\">&gt;</span> <span class=\"ruby-value\">1</span> <span class=\"ruby-value\">0</span>\n     <span class=\"ruby-value\">0</span> <span class=\"ruby-value\">1</span>\n</pre>\n"],["imag","Matrix","Matrix.html#method-i-imag","()",""],["imaginary","Matrix","Matrix.html#method-i-imaginary","()","<p>Returns the imaginary part of the matrix.\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Matrix</span>[[<span class=\"ruby-constant\">Complex</span>(<span class=\"ruby-value\">1</span>,<span class=\"ruby-value\">2</span>), <span class=\"ruby-constant\">Complex</span>(<span class=\"ruby-value\">0</span>,<span class=\"ruby-value\">1</span>), <span class=\"ruby-value\">0</span>], [<span class=\"ruby-value\">1</span>, <span class=\"ruby-value\">2</span>, <span class=\"ruby-value\">3</span>]]\n  =<span class=\"ruby-operator\">&gt;</span> <span class=\"ruby-value\">1</span><span class=\"ruby-operator\">+</span><span class=\"ruby-value\">2</span><span class=\"ruby-identifier\">i</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["index","Matrix","Matrix.html#method-i-index","(*args)","<p>The index method is specialized to return the index as [row, column] It\nalso accepts an optional <code>selector</code> …\n"],["inner_product","Vector","Vector.html#method-i-inner_product","(v)","<p>Returns the inner product of this vector with the other.\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Vector</span>[<span class=\"ruby-value\">4</span>,<span class=\"ruby-value\">7</span>].<span class=\"ruby-identifier\">inner_product</span> <span class=\"ruby-constant\">Vector</span>[<span class=\"ruby-value\">10</span>,<span class=\"ruby-value\">1</span>]  =<span class=\"ruby-operator\">&gt;</span> <span class=\"ruby-value\">47</span>\n</pre>\n"],["inspect","Matrix","Matrix.html#method-i-inspect","()","<p>Overrides Object#inspect\n"],["inspect","Vector","Vector.html#method-i-inspect","()","<p>Overrides Object#inspect\n"],["inv","Matrix","Matrix.html#method-i-inv","()",""],["inverse","Matrix","Matrix.html#method-i-inverse","()","<p>Returns the inverse of the matrix.\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Matrix</span>[[<span class=\"ruby-value\">-1</span>, <span class=\"ruby-value\">-1</span>], [<span class=\"ruby-value\">0</span>, <span class=\"ruby-value\">-1</span>]].<span class=\"ruby-identifier\">inverse</span>\n  =<span class=\"ruby-operator\">&gt;</span> <span class=\"ruby-value\">-1</span>  <span class=\"ruby-value\">1</span>\n      <span class=\"ruby-value\">0</span> <span class=\"ruby-operator\">-</span><span class=\"ruby-value\">1</span>\n</pre>\n"],["l","Matrix::LUPDecomposition","Matrix/LUPDecomposition.html#method-i-l","()",""],["lower_triangular?","Matrix","Matrix.html#method-i-lower_triangular-3F","()","<p>Returns <code>true</code> is this is a lower triangular matrix.\n"],["lup","Matrix","Matrix.html#method-i-lup","()","<p>Returns the LUP decomposition of the matrix; see\n<code>LUPDecomposition</code>.\n\n<pre>a = Matrix[[1, 2], [3, 4]]\nl, u, p ...</pre>\n"],["lup_decomposition","Matrix","Matrix.html#method-i-lup_decomposition","()",""],["magnitude","Vector","Vector.html#method-i-magnitude","()","<p>Returns the modulus (Pythagorean distance) of the vector.\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Vector</span>[<span class=\"ruby-value\">5</span>,<span class=\"ruby-value\">8</span>,<span class=\"ruby-value\">2</span>].<span class=\"ruby-identifier\">r</span> =<span class=\"ruby-operator\">&gt;</span> <span class=\"ruby-value\">9.643650761</span>\n</pre>\n"],["map","Matrix","Matrix.html#method-i-map","()",""],["map","Vector","Vector.html#method-i-map","()",""],["map2","Vector","Vector.html#method-i-map2","(v)","<p>Like Vector#collect2, but returns a Vector instead of an Array.\n"],["minor","Matrix","Matrix.html#method-i-minor","(*param)","<p>Returns a section of the matrix.  The parameters are either:\n<p>start_row, nrows, start_col, ncols; OR\n<p>row_range …\n"],["new","Matrix","Matrix.html#method-c-new","(rows, column_size = rows[0].size)","<p>Matrix.new is private; use Matrix.rows, columns, [], etc… to create.\n"],["new","Matrix::EigenvalueDecomposition","Matrix/EigenvalueDecomposition.html#method-c-new","(a)","<p>Constructs the eigenvalue decomposition for a square matrix <code>A</code>\n"],["new","Matrix::LUPDecomposition","Matrix/LUPDecomposition.html#method-c-new","(a)",""],["new","Vector","Vector.html#method-c-new","(array)","<p>Vector.new is private; use Vector[] or Vector.elements to create.\n"],["norm","Vector","Vector.html#method-i-norm","()",""],["normal?","Matrix","Matrix.html#method-i-normal-3F","()","<p>Returns <code>true</code> is this is a normal matrix. Raises an error if\nmatrix is not square.\n"],["normalize","Vector","Vector.html#method-i-normalize","()","<p>Returns a new vector with the same direction but with norm 1.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">v</span> = <span class=\"ruby-constant\">Vector</span>[<span class=\"ruby-value\">5</span>,<span class=\"ruby-value\">8</span>,<span class=\"ruby-value\">2</span>].<span class=\"ruby-identifier\">normalize</span>\n<span class=\"ruby-comment\"># =&gt; Vector[0.5184758473652127, ...</span>\n</pre>\n"],["orthogonal?","Matrix","Matrix.html#method-i-orthogonal-3F","()","<p>Returns <code>true</code> is this is an orthogonal matrix Raises an error\nif matrix is not square.\n"],["p","Matrix::LUPDecomposition","Matrix/LUPDecomposition.html#method-i-p","()","<p>Returns the permutation matrix <code>P</code>\n"],["permutation?","Matrix","Matrix.html#method-i-permutation-3F","()","<p>Returns <code>true</code> is this is a permutation matrix Raises an error\nif matrix is not square.\n"],["r","Vector","Vector.html#method-i-r","()",""],["rank","Matrix","Matrix.html#method-i-rank","()","<p>Returns the rank of the matrix. Beware that using Float values can yield\nerroneous results because of …\n"],["rank_e","Matrix","Matrix.html#method-i-rank_e","()","<p>deprecated; use Matrix#rank\n"],["real","Matrix","Matrix.html#method-i-real","()","<p>Returns the real part of the matrix.\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Matrix</span>[[<span class=\"ruby-constant\">Complex</span>(<span class=\"ruby-value\">1</span>,<span class=\"ruby-value\">2</span>), <span class=\"ruby-constant\">Complex</span>(<span class=\"ruby-value\">0</span>,<span class=\"ruby-value\">1</span>), <span class=\"ruby-value\">0</span>], [<span class=\"ruby-value\">1</span>, <span class=\"ruby-value\">2</span>, <span class=\"ruby-value\">3</span>]]\n  =<span class=\"ruby-operator\">&gt;</span> <span class=\"ruby-value\">1</span><span class=\"ruby-operator\">+</span><span class=\"ruby-value\">2</span><span class=\"ruby-identifier\">i</span>  <span class=\"ruby-identifier\">i</span>  <span class=\"ruby-operator\">...</span>\n</pre>\n"],["real?","Matrix","Matrix.html#method-i-real-3F","()","<p>Returns <code>true</code> if all entries of the matrix are real.\n"],["rect","Matrix","Matrix.html#method-i-rect","()","<p>Returns an array containing matrices corresponding to the real and\nimaginary parts of the matrix\n<p>m.rect …\n"],["rectangular","Matrix","Matrix.html#method-i-rectangular","()",""],["regular?","Matrix","Matrix.html#method-i-regular-3F","()","<p>Returns <code>true</code> if this is a regular (i.e. non-singular) matrix.\n"],["round","Matrix","Matrix.html#method-i-round","(ndigits=0)","<p>Returns a matrix with entries rounded to the given precision (see\nFloat#round)\n"],["row","Matrix","Matrix.html#method-i-row","(i)","<p>Returns row vector number <code>i</code> of the matrix as a Vector\n(starting at 0 like an array).  When a block is …\n"],["row_size","Matrix","Matrix.html#method-i-row_size","()","<p>Returns the number of rows.\n"],["row_vector","Matrix","Matrix.html#method-c-row_vector","(row)","<p>Creates a single-row matrix where the values of that row are as given in\n<code>row</code>.\n\n<pre>Matrix.row_vector([4,5,6]) ...</pre>\n"],["row_vectors","Matrix","Matrix.html#method-i-row_vectors","()","<p>Returns an array of the row vectors of the matrix.  See Vector.\n"],["rows","Matrix","Matrix.html#method-c-rows","(rows, copy = true)","<p>Creates a matrix where <code>rows</code> is an array of arrays, each of\nwhich is a row of the matrix.  If the optional …\n"],["scalar","Matrix","Matrix.html#method-c-scalar","(n, value)","<p>Creates an <code>n</code> by <code>n</code> diagonal matrix where each\ndiagonal element is <code>value</code>.\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Matrix</span>.<span class=\"ruby-identifier\">scalar</span>(<span class=\"ruby-value\">2</span>, <span class=\"ruby-value\">5</span>)\n  =<span class=\"ruby-operator\">&gt;</span> <span class=\"ruby-value\">5</span> <span class=\"ruby-value\">0</span>\n <span class=\"ruby-operator\">...</span>\n</pre>\n"],["singular?","Matrix","Matrix.html#method-i-singular-3F","()","<p>Returns <code>true</code> is this is a singular matrix.\n"],["singular?","Matrix::LUPDecomposition","Matrix/LUPDecomposition.html#method-i-singular-3F","()","<p>Returns <code>true</code> if <code>U</code>, and hence <code>A</code>, is\nsingular.\n"],["size","Vector","Vector.html#method-i-size","()","<p>Returns the number of elements in the vector.\n"],["solve","Matrix::LUPDecomposition","Matrix/LUPDecomposition.html#method-i-solve","(b)","<p>Returns <code>m</code> so that <code>A*m = b</code>, or equivalently so\nthat <code>L*U*m = P*b</code> <code>b</code> can be a Matrix or a Vector\n"],["square?","Matrix","Matrix.html#method-i-square-3F","()","<p>Returns <code>true</code> is this is a square matrix.\n"],["symmetric?","Matrix","Matrix.html#method-i-symmetric-3F","()","<p>Returns <code>true</code> is this is a symmetric matrix. Raises an error if\nmatrix is not square.\n"],["t","Matrix","Matrix.html#method-i-t","()",""],["to_a","Matrix","Matrix.html#method-i-to_a","()","<p>Returns an array of arrays that describe the rows of the matrix.\n"],["to_a","Matrix::EigenvalueDecomposition","Matrix/EigenvalueDecomposition.html#method-i-to_a","()",""],["to_a","Matrix::LUPDecomposition","Matrix/LUPDecomposition.html#method-i-to_a","()",""],["to_a","Vector","Vector.html#method-i-to_a","()","<p>Returns the elements of the vector in an array.\n"],["to_ary","Matrix::EigenvalueDecomposition","Matrix/EigenvalueDecomposition.html#method-i-to_ary","()","<p>Returns [eigenvector_matrix, eigenvalue_matrix, eigenvector_matrix_inv]\n"],["to_ary","Matrix::LUPDecomposition","Matrix/LUPDecomposition.html#method-i-to_ary","()","<p>Returns <code>L</code>, <code>U</code>, <code>P</code> in an array\n"],["to_s","Matrix","Matrix.html#method-i-to_s","()","<p>Overrides Object#to_s\n"],["to_s","Vector","Vector.html#method-i-to_s","()","<p>Overrides Object#to_s\n"],["tr","Matrix","Matrix.html#method-i-tr","()",""],["trace","Matrix","Matrix.html#method-i-trace","()","<p>Returns the trace (sum of diagonal elements) of the matrix.\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Matrix</span>[[<span class=\"ruby-value\">7</span>,<span class=\"ruby-value\">6</span>], [<span class=\"ruby-value\">3</span>,<span class=\"ruby-value\">9</span>]].<span class=\"ruby-identifier\">trace</span>\n  =<span class=\"ruby-operator\">&gt;</span> <span class=\"ruby-value\">16</span>\n</pre>\n"],["transpose","Matrix","Matrix.html#method-i-transpose","()","<p>Returns the transpose of the matrix.\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Matrix</span>[[<span class=\"ruby-value\">1</span>,<span class=\"ruby-value\">2</span>], [<span class=\"ruby-value\">3</span>,<span class=\"ruby-value\">4</span>], [<span class=\"ruby-value\">5</span>,<span class=\"ruby-value\">6</span>]]\n  =<span class=\"ruby-operator\">&gt;</span> <span class=\"ruby-value\">1</span> <span class=\"ruby-value\">2</span>\n     <span class=\"ruby-value\">3</span> <span class=\"ruby-value\">4</span>\n     <span class=\"ruby-value\">5</span> <span class=\"ruby-value\">6</span>\n<span class=\"ruby-constant\">Matrix</span>[[<span class=\"ruby-value\">1</span>,<span class=\"ruby-value\">2</span>], <span class=\"ruby-operator\">...</span>\n</pre>\n"],["u","Matrix::LUPDecomposition","Matrix/LUPDecomposition.html#method-i-u","()","<p>Returns the upper triangular factor <code>U</code>\n"],["unit","Matrix","Matrix.html#method-c-unit","(n)",""],["unitary?","Matrix","Matrix.html#method-i-unitary-3F","()","<p>Returns <code>true</code> is this is a unitary matrix Raises an error if\nmatrix is not square.\n"],["upper_triangular?","Matrix","Matrix.html#method-i-upper_triangular-3F","()","<p>Returns <code>true</code> is this is an upper triangular matrix.\n"],["v","Matrix::EigenvalueDecomposition","Matrix/EigenvalueDecomposition.html#method-i-v","()",""],["v_inv","Matrix::EigenvalueDecomposition","Matrix/EigenvalueDecomposition.html#method-i-v_inv","()",""],["zero","Matrix","Matrix.html#method-c-zero","(row_size, column_size = row_size)","<p>Creates a zero matrix.\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Matrix</span>.<span class=\"ruby-identifier\">zero</span>(<span class=\"ruby-value\">2</span>)\n  =<span class=\"ruby-operator\">&gt;</span> <span class=\"ruby-value\">0</span> <span class=\"ruby-value\">0</span>\n     <span class=\"ruby-value\">0</span> <span class=\"ruby-value\">0</span>\n</pre>\n"],["zero?","Matrix","Matrix.html#method-i-zero-3F","()","<p>Returns <code>true</code> is this is a matrix with only zero elements\n"]]}}