var search_data = {"index":{"searchIndex":["minitest","assertion","assertions","skip","unit","testcase","_run()","_run_anything()","_run_suite()","_run_suites()","add_setup_hook()","add_teardown_hook()","after_tests()","assert()","assert_block()","assert_empty()","assert_equal()","assert_in_delta()","assert_in_epsilon()","assert_includes()","assert_instance_of()","assert_kind_of()","assert_match()","assert_nil()","assert_operator()","assert_output()","assert_raises()","assert_respond_to()","assert_same()","assert_send()","assert_silent()","assert_throws()","autorun()","capture_io()","diff()","diff()","diff=()","exception_details()","flunk()","i_suck_and_my_tests_are_order_dependent!()","io()","io?()","message()","mu_pp()","mu_pp_for_diff()","options()","out()","output()","output()","output=()","pass()","passed?()","plugins()","process_args()","puke()","refute()","refute_empty()","refute_equal()","refute_in_delta()","refute_in_epsilon()","refute_includes()","refute_instance_of()","refute_kind_of()","refute_match()","refute_nil()","refute_operator()","refute_respond_to()","refute_same()","run()","run()","run_tests()","runner()","runner=()","setup()","skip()","status()","teardown()"],"longSearchIndex":["minitest","minitest::assertion","minitest::assertions","minitest::skip","minitest::unit","minitest::unit::testcase","minitest::unit#_run()","minitest::unit#_run_anything()","minitest::unit#_run_suite()","minitest::unit#_run_suites()","minitest::unit::testcase::add_setup_hook()","minitest::unit::testcase::add_teardown_hook()","minitest::unit::after_tests()","minitest::assertions#assert()","minitest::assertions#assert_block()","minitest::assertions#assert_empty()","minitest::assertions#assert_equal()","minitest::assertions#assert_in_delta()","minitest::assertions#assert_in_epsilon()","minitest::assertions#assert_includes()","minitest::assertions#assert_instance_of()","minitest::assertions#assert_kind_of()","minitest::assertions#assert_match()","minitest::assertions#assert_nil()","minitest::assertions#assert_operator()","minitest::assertions#assert_output()","minitest::assertions#assert_raises()","minitest::assertions#assert_respond_to()","minitest::assertions#assert_same()","minitest::assertions#assert_send()","minitest::assertions#assert_silent()","minitest::assertions#assert_throws()","minitest::unit::autorun()","minitest::assertions#capture_io()","minitest::assertions#diff()","minitest::assertions::diff()","minitest::assertions::diff=()","minitest::assertions#exception_details()","minitest::assertions#flunk()","minitest::unit::testcase::i_suck_and_my_tests_are_order_dependent!()","minitest::unit::testcase#io()","minitest::unit::testcase#io?()","minitest::assertions#message()","minitest::assertions#mu_pp()","minitest::assertions#mu_pp_for_diff()","minitest::unit#options()","minitest::unit::out()","minitest::unit#output()","minitest::unit::output()","minitest::unit::output=()","minitest::assertions#pass()","minitest::unit::testcase#passed?()","minitest::unit::plugins()","minitest::unit#process_args()","minitest::unit#puke()","minitest::assertions#refute()","minitest::assertions#refute_empty()","minitest::assertions#refute_equal()","minitest::assertions#refute_in_delta()","minitest::assertions#refute_in_epsilon()","minitest::assertions#refute_includes()","minitest::assertions#refute_instance_of()","minitest::assertions#refute_kind_of()","minitest::assertions#refute_match()","minitest::assertions#refute_nil()","minitest::assertions#refute_operator()","minitest::assertions#refute_respond_to()","minitest::assertions#refute_same()","minitest::unit#run()","minitest::unit::testcase#run()","minitest::unit#run_tests()","minitest::unit::runner()","minitest::unit::runner=()","minitest::unit::testcase#setup()","minitest::assertions#skip()","minitest::unit#status()","minitest::unit::testcase#teardown()"],"info":[["MiniTest","","MiniTest.html","","<p>Minimal (mostly drop-in) replacement for test-unit.\n<p>minitest/*\n<p>rubyforge.org/projects/bfts\n"],["MiniTest::Assertion","","MiniTest/Assertion.html","","<p>Assertion base class\n"],["MiniTest::Assertions","","MiniTest/Assertions.html","","<p>MiniTest Assertions.  All assertion methods accept a <code>msg</code> which\nis printed if the assertion fails.\n"],["MiniTest::Skip","","MiniTest/Skip.html","","<p>Assertion raised when skipping a test\n"],["MiniTest::Unit","","MiniTest/Unit.html","",""],["MiniTest::Unit::TestCase","","MiniTest/Unit/TestCase.html","","<p>Subclass TestCase to create your own tests. Typically you’ll want a\nTestCase subclass per implementation …\n"],["_run","MiniTest::Unit","MiniTest/Unit.html#method-i-_run","(args = [])","<p>Top level driver, controls all output and filtering.\n"],["_run_anything","MiniTest::Unit","MiniTest/Unit.html#method-i-_run_anything","(type)",""],["_run_suite","MiniTest::Unit","MiniTest/Unit.html#method-i-_run_suite","(suite, type)",""],["_run_suites","MiniTest::Unit","MiniTest/Unit.html#method-i-_run_suites","(suites, type)",""],["add_setup_hook","MiniTest::Unit::TestCase","MiniTest/Unit/TestCase.html#method-c-add_setup_hook","(arg=nil, &block)","<p>Adds a block of code that will be executed before every TestCase is run.\nEquivalent to <code>setup</code>, but usable …\n"],["add_teardown_hook","MiniTest::Unit::TestCase","MiniTest/Unit/TestCase.html#method-c-add_teardown_hook","(arg=nil, &block)","<p>Adds a block of code that will be executed after every TestCase is run.\nEquivalent to <code>teardown</code>, but usable …\n"],["after_tests","MiniTest::Unit","MiniTest/Unit.html#method-c-after_tests","()","<p>A simple hook allowing you to run a block of code after the tests are done.\nEg:\n\n<pre>MiniTest::Unit.after_tests ...</pre>\n"],["assert","MiniTest::Assertions","MiniTest/Assertions.html#method-i-assert","(test, msg = nil)","<p>Fails unless <code>test</code> is a true value.\n"],["assert_block","MiniTest::Assertions","MiniTest/Assertions.html#method-i-assert_block","(msg = nil)","<p>Fails unless the block returns a true value.\n"],["assert_empty","MiniTest::Assertions","MiniTest/Assertions.html#method-i-assert_empty","(obj, msg = nil)","<p>Fails unless <code>obj</code> is empty.\n"],["assert_equal","MiniTest::Assertions","MiniTest/Assertions.html#method-i-assert_equal","(exp, act, msg = nil)","<p>Fails unless <code>exp == act</code> printing the difference between the\ntwo, if possible.\n<p>If there is no visible difference …\n"],["assert_in_delta","MiniTest::Assertions","MiniTest/Assertions.html#method-i-assert_in_delta","(exp, act, delta = 0.001, msg = nil)","<p>For comparing Floats.  Fails unless <code>exp</code> and <code>act</code>\nare within <code>delta</code> of each other.\n\n<pre>assert_in_delta Math::PI, ...</pre>\n"],["assert_in_epsilon","MiniTest::Assertions","MiniTest/Assertions.html#method-i-assert_in_epsilon","(a, b, epsilon = 0.001, msg = nil)","<p>For comparing Floats.  Fails unless <code>exp</code> and <code>act</code>\nhave a relative error less than <code>epsilon</code>.\n"],["assert_includes","MiniTest::Assertions","MiniTest/Assertions.html#method-i-assert_includes","(collection, obj, msg = nil)","<p>Fails unless <code>collection</code> includes <code>obj</code>.\n"],["assert_instance_of","MiniTest::Assertions","MiniTest/Assertions.html#method-i-assert_instance_of","(cls, obj, msg = nil)","<p>Fails unless <code>obj</code> is an instace of <code>cls</code>.\n"],["assert_kind_of","MiniTest::Assertions","MiniTest/Assertions.html#method-i-assert_kind_of","(cls, obj, msg = nil)","<p>Fails unless <code>obj</code> is a kind of <code>cls</code>.\n"],["assert_match","MiniTest::Assertions","MiniTest/Assertions.html#method-i-assert_match","(exp, act, msg = nil)","<p>Fails unless <code>exp</code> is <code>=~</code> <code>act</code>.\n"],["assert_nil","MiniTest::Assertions","MiniTest/Assertions.html#method-i-assert_nil","(obj, msg = nil)","<p>Fails unless <code>obj</code> is nil\n"],["assert_operator","MiniTest::Assertions","MiniTest/Assertions.html#method-i-assert_operator","(o1, op, o2, msg = nil)","<p>For testing equality operators and so-forth.\n\n<pre>assert_operator 5, :&lt;=, 4</pre>\n"],["assert_output","MiniTest::Assertions","MiniTest/Assertions.html#method-i-assert_output","(stdout = nil, stderr = nil)","<p>Fails if stdout or stderr do not output the expected results. Pass in nil\nif you don’t care about that …\n"],["assert_raises","MiniTest::Assertions","MiniTest/Assertions.html#method-i-assert_raises","(*exp)","<p>Fails unless the block raises one of <code>exp</code>\n"],["assert_respond_to","MiniTest::Assertions","MiniTest/Assertions.html#method-i-assert_respond_to","(obj, meth, msg = nil)","<p>Fails unless <code>obj</code> responds to <code>meth</code>.\n"],["assert_same","MiniTest::Assertions","MiniTest/Assertions.html#method-i-assert_same","(exp, act, msg = nil)","<p>Fails unless <code>exp</code> and <code>act</code> are #equal?\n"],["assert_send","MiniTest::Assertions","MiniTest/Assertions.html#method-i-assert_send","(send_ary, m = nil)","<p><code>send_ary</code> is a receiver, message and arguments.\n<p>Fails unless the call returns a true value TODO: I should …\n"],["assert_silent","MiniTest::Assertions","MiniTest/Assertions.html#method-i-assert_silent","()","<p>Fails if the block outputs anything to stderr or stdout.\n<p>See also: #assert_output\n"],["assert_throws","MiniTest::Assertions","MiniTest/Assertions.html#method-i-assert_throws","(sym, msg = nil)","<p>Fails unless the block throws <code>sym</code>\n"],["autorun","MiniTest::Unit","MiniTest/Unit.html#method-c-autorun","()","<p>Registers MiniTest::Unit to run tests at process exit\n"],["capture_io","MiniTest::Assertions","MiniTest/Assertions.html#method-i-capture_io","()","<p>Captures $stdout and $stderr into strings:\n\n<pre>out, err = capture_io do\n  warn &quot;You did a bad thing&quot;\nend\n ...</pre>\n"],["diff","MiniTest::Assertions","MiniTest/Assertions.html#method-i-diff","(exp, act)","<p>Returns a diff between <code>exp</code> and <code>act</code>. If there is\nno known diff command or if it doesn’t make sense to …\n"],["diff","MiniTest::Assertions","MiniTest/Assertions.html#method-c-diff","()","<p>Returns the diff command to use in #diff. Tries to intelligently figure out\nwhat diff to use.\n"],["diff=","MiniTest::Assertions","MiniTest/Assertions.html#method-c-diff-3D","(o)","<p>Set the diff command to use in #diff.\n"],["exception_details","MiniTest::Assertions","MiniTest/Assertions.html#method-i-exception_details","(e, msg)","<p>Returns details for exception <code>e</code>\n"],["flunk","MiniTest::Assertions","MiniTest/Assertions.html#method-i-flunk","(msg = nil)","<p>Fails with <code>msg</code>\n"],["i_suck_and_my_tests_are_order_dependent!","MiniTest::Unit::TestCase","MiniTest/Unit/TestCase.html#method-c-i_suck_and_my_tests_are_order_dependent-21","()","<p>Call this at the top of your tests when you absolutely positively need to\nhave ordered tests. In doing …\n"],["io","MiniTest::Unit::TestCase","MiniTest/Unit/TestCase.html#method-i-io","()",""],["io?","MiniTest::Unit::TestCase","MiniTest/Unit/TestCase.html#method-i-io-3F","()",""],["message","MiniTest::Assertions","MiniTest/Assertions.html#method-i-message","(msg = nil, ending = \".\", &default)","<p>Returns a proc that will output <code>msg</code> along with the default\nmessage.\n"],["mu_pp","MiniTest::Assertions","MiniTest/Assertions.html#method-i-mu_pp","(obj)","<p>This returns a human-readable version of <code>obj</code>. By default\n#inspect is called. You can override this to …\n"],["mu_pp_for_diff","MiniTest::Assertions","MiniTest/Assertions.html#method-i-mu_pp_for_diff","(obj)","<p>This returns a diff-able human-readable version of <code>obj</code>. This\ndiffers from the regular mu_pp because it …\n"],["options","MiniTest::Unit","MiniTest/Unit.html#method-i-options","()",""],["out","MiniTest::Unit","MiniTest/Unit.html#method-c-out","()","<p>Returns the stream to use for output.\n<p>DEPRECATED: use ::output instead.\n"],["output","MiniTest::Unit","MiniTest/Unit.html#method-i-output","()",""],["output","MiniTest::Unit","MiniTest/Unit.html#method-c-output","()","<p>Returns the stream to use for output.\n"],["output=","MiniTest::Unit","MiniTest/Unit.html#method-c-output-3D","(stream)","<p>Sets MiniTest::Unit to write output to <code>stream</code>.  $stdout is the\ndefault output\n"],["pass","MiniTest::Assertions","MiniTest/Assertions.html#method-i-pass","(msg = nil)","<p>used for counting assertions\n"],["passed?","MiniTest::Unit::TestCase","MiniTest/Unit/TestCase.html#method-i-passed-3F","()","<p>Returns true if the test passed.\n"],["plugins","MiniTest::Unit","MiniTest/Unit.html#method-c-plugins","()","<p>Return all plugins’ run methods (methods that start with “run_”).\n"],["process_args","MiniTest::Unit","MiniTest/Unit.html#method-i-process_args","(args = [])",""],["puke","MiniTest::Unit","MiniTest/Unit.html#method-i-puke","(klass, meth, e)","<p>Writes status for failed test <code>meth</code> in <code>klass</code> which\nfinished with exception <code>e</code>\n"],["refute","MiniTest::Assertions","MiniTest/Assertions.html#method-i-refute","(test, msg = nil)","<p>Fails if <code>test</code> is a true value\n"],["refute_empty","MiniTest::Assertions","MiniTest/Assertions.html#method-i-refute_empty","(obj, msg = nil)","<p>Fails if <code>obj</code> is empty.\n"],["refute_equal","MiniTest::Assertions","MiniTest/Assertions.html#method-i-refute_equal","(exp, act, msg = nil)","<p>Fails if <code>exp == act</code>.\n<p>For floats use refute_in_delta.\n"],["refute_in_delta","MiniTest::Assertions","MiniTest/Assertions.html#method-i-refute_in_delta","(exp, act, delta = 0.001, msg = nil)","<p>For comparing Floats.  Fails if <code>exp</code> is within\n<code>delta</code> of <code>act</code>\n\n<pre>refute_in_delta Math::PI, (22.0 / 7.0)</pre>\n"],["refute_in_epsilon","MiniTest::Assertions","MiniTest/Assertions.html#method-i-refute_in_epsilon","(a, b, epsilon = 0.001, msg = nil)","<p>For comparing Floats.  Fails if <code>exp</code> and <code>act</code> have\na relative error less than <code>epsilon</code>.\n"],["refute_includes","MiniTest::Assertions","MiniTest/Assertions.html#method-i-refute_includes","(collection, obj, msg = nil)","<p>Fails if <code>collection</code> includes <code>obj</code>\n"],["refute_instance_of","MiniTest::Assertions","MiniTest/Assertions.html#method-i-refute_instance_of","(cls, obj, msg = nil)","<p>Fails if <code>obj</code> is an instance of <code>cls</code>\n"],["refute_kind_of","MiniTest::Assertions","MiniTest/Assertions.html#method-i-refute_kind_of","(cls, obj, msg = nil)","<p>Fails if <code>obj</code> is a kind of <code>cls</code>\n"],["refute_match","MiniTest::Assertions","MiniTest/Assertions.html#method-i-refute_match","(exp, act, msg = nil)","<p>Fails if <code>exp</code> <code>=~</code> <code>act</code>\n"],["refute_nil","MiniTest::Assertions","MiniTest/Assertions.html#method-i-refute_nil","(obj, msg = nil)","<p>Fails if <code>obj</code> is nil.\n"],["refute_operator","MiniTest::Assertions","MiniTest/Assertions.html#method-i-refute_operator","(o1, op, o2, msg = nil)","<p>Fails if <code>o1</code> is not <code>op</code> <code>o2</code>. Eg:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">refute_operator</span> <span class=\"ruby-value\">1</span>, :<span class=\"ruby-operator\">&gt;</span>, <span class=\"ruby-value\">2</span> <span class=\"ruby-comment\">#=&gt; pass</span>\n<span class=\"ruby-identifier\">refute_operator</span> <span class=\"ruby-value\">1</span>, :<span class=\"ruby-operator\">&lt;</span>, <span class=\"ruby-value\">2</span> <span class=\"ruby-comment\">#=&gt; fail</span>\n</pre>\n"],["refute_respond_to","MiniTest::Assertions","MiniTest/Assertions.html#method-i-refute_respond_to","(obj, meth, msg = nil)","<p>Fails if <code>obj</code> responds to the message <code>meth</code>.\n"],["refute_same","MiniTest::Assertions","MiniTest/Assertions.html#method-i-refute_same","(exp, act, msg = nil)","<p>Fails if <code>exp</code> is the same (by object identity) as\n<code>act</code>.\n"],["run","MiniTest::Unit","MiniTest/Unit.html#method-i-run","(args = [])","<p>Begins the full test run. Delegates to <code>runner</code>‘s #_run method.\n"],["run","MiniTest::Unit::TestCase","MiniTest/Unit/TestCase.html#method-i-run","(runner)","<p>Runs the tests reporting the status to <code>runner</code>\n"],["run_tests","MiniTest::Unit","MiniTest/Unit.html#method-i-run_tests","()","<p>Runs test suites matching <code>filter</code>.\n"],["runner","MiniTest::Unit","MiniTest/Unit.html#method-c-runner","()","<p>Returns the MiniTest::Unit subclass instance that will be used to run the\ntests. A MiniTest::Unit instance …\n"],["runner=","MiniTest::Unit","MiniTest/Unit.html#method-c-runner-3D","(runner)","<p>Tells MiniTest::Unit to delegate to <code>runner</code>, an instance of a\nMiniTest::Unit subclass, when MiniTest::Unit#run …\n"],["setup","MiniTest::Unit::TestCase","MiniTest/Unit/TestCase.html#method-i-setup","()","<p>Runs before every test. Use this to refactor test initialization.\n"],["skip","MiniTest::Assertions","MiniTest/Assertions.html#method-i-skip","(msg = nil, bt = caller)","<p>Skips the current test. Gets listed at the end of the run but doesn’t cause\na failure exit code.\n"],["status","MiniTest::Unit","MiniTest/Unit.html#method-i-status","(io = self.output)","<p>Writes status to <code>io</code>\n"],["teardown","MiniTest::Unit::TestCase","MiniTest/Unit/TestCase.html#method-i-teardown","()","<p>Runs after every test. Use this to refactor test cleanup.\n"]]}}