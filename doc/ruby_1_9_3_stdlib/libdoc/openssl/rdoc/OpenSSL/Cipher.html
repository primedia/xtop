<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <!-- classpage -- >
    <!-- RD version: 0.26.0  -->
  <meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />
  
  <meta content="2014-04-26 10:51:37 -0700" http-equiv="change-date" />
  <!-- rel_prefix  = '..'  ENV['RDOC_FOR_WEBSITE']   = false-->
    
  <!-- rel_prefix = '..'   asset_rel_prefix = '..'  --> 
  <title>Class: OpenSSL::Cipher (Ruby 1.9.3) </title>
  <!-- link rel="stylesheet" href="..css/obf.css"  -->
  <link rel="stylesheet" href="../css/inuit.css" >
  <link rel="stylesheet" href="../css/grid.inuit.css" >
  <link rel="stylesheet" href="../css/2011.css" type="text/css" >
  <link rel="stylesheet" href="../css/rdoc.css" type="text/css" >

  <script src="../js/jquery.js" type="text/javascript" charset="utf-8"></script>
  <script src="../js/thickbox-compressed.js" type="text/javascript" charset="utf-8"></script>
  <script src="../js/quicksearch.js" type="text/javascript" charset="utf-8"></script>
  <script src="../js/rubydoc.js" type="text/javascript" charset="utf-8"></script> 

 
<script src="../js/highlight.min.js"></script>
<script> 
  hljs.tabReplace = '  ';
  hljs.initHighlightingOnLoad();
  </script> 

  <style type='text/css'>

    #vulns-alert #vulns{
      background-color: #c33 ! important;
      width: 100%;
      text-align: center;
   }
   
   #vulns-alert #vulns a {
    color: #F99 ! important;
   }
 </style>

</head>

<body id="top" class="class rdocstar">
<div id='actionbar' >
<div class='wrapper'>
  <ul class='grids g0'></ul>
</div>
<span id='vulns-alert'></span>
</div> <!-- end action bar -->
 <div class='wrapper'>
  <div id="metadata">
    <div id="home-metadata">
      <div id="home-section" class="section">
        <h3 class="section-header">
          <a href="../index.html">Home</a>
          <a href="../index.html#classes">Classes</a>
          <a href="../index.html#methods">Methods</a>
          
          
          <!-- br><a id='alternateFormatLink' class='rotate' href="#" onclick='matchingYardUrl()'>YARD version</a -->
          
        </h3>
      </div>
    </div>

    <div id="file-metadata">
      <div id="file-list-section" class="section">
        <h3 class="section-header">In Files</h3>
        <div class="section-body">
          <ul id='file-metadata'>

          
          
          
          <li class='in-file'>openssl/lib/openssl/cipher.rb</li>      
            
          
          <li class='in-file'>openssl/ossl.c</li>      
            
          </ul>
        </div>
      </div>

      
    </div>

    <div id="class-metadata">
      
      <!-- Parent Class -->
      <div id="parent-class-section" class="section">
        <h3 class="section-header">Parent</h3>
        
        <p class="link">Object</p>
        
      </div>
      

      

      
      <!-- Namespace Contents -->
      <div id="namespace-list-section" class="section">
        <h3 class="section-header">Namespace</h3>
        <ul class="link-list">
          
          <li><span class="type">CLASS</span> <a href="Cipher/Cipher.html">OpenSSL::Cipher::Cipher</a></li>
          
          <li><span class="type">CLASS</span> <a href="Cipher/CipherError.html">OpenSSL::Cipher::CipherError</a></li>
          
        </ul>
      </div>
      

      
      <!-- Method Quickref -->
      <div id="method-list-section" class="section">
        <h3 class="section-header">Methods</h3>
        <ul class="link-list">
          
          <li><a href="#method-c-ciphers">::ciphers</a></li>
          
          <li><a href="#method-c-new">::new</a></li>
          
          <li><a href="#method-i-decrypt">#decrypt</a></li>
          
          <li><a href="#method-i-encrypt">#encrypt</a></li>
          
          <li><a href="#method-i-final">#final</a></li>
          
          <li><a href="#method-i-iv-3D">#iv=</a></li>
          
          <li><a href="#method-i-key-3D">#key=</a></li>
          
          <li><a href="#method-i-key_len-3D">#key_len=</a></li>
          
          <li><a href="#method-i-name">#name</a></li>
          
          <li><a href="#method-i-padding-3D">#padding=</a></li>
          
          <li><a href="#method-i-pkcs5_keyivgen">#pkcs5_keyivgen</a></li>
          
          <li><a href="#method-i-random_iv">#random_iv</a></li>
          
          <li><a href="#method-i-random_key">#random_key</a></li>
          
          <li><a href="#method-i-reset">#reset</a></li>
          
          <li><a href="#method-i-update">#update</a></li>
          
        </ul>
      </div>
      

      
    </div>

    <div id="project-metadata">
      
      

      <div id="classindex-section" class="section project-section">
        <h3 class="section-header">Class/Module Index
          <span class="search-toggle"><img src="../images/find.png"
            height="16" width="16" alt="[+]"
            title="show/hide quicksearch" /></span></h3>
        <form action="#" method="get" accept-charset="utf-8" class="initially-hidden">
        <fieldset>
          <legend>Quicksearch</legend>
          <input type="text" name="quicksearch" value=""
            class="quicksearch-field" />
        </fieldset>
        </form>

        <ul class="link-list">
          
          
          
          <li><a href="../Integer.html">Integer</a></li>
        
          
          
          <li><a href="../OpenSSL.html">OpenSSL</a></li>
        
          
          
          <li><a href="../OpenSSL/ASN1.html">OpenSSL::ASN1</a></li>
        
          
          
          <li><a href="../OpenSSL/ASN1/ASN1Data.html">OpenSSL::ASN1::ASN1Data</a></li>
        
          
          
          <li><a href="../OpenSSL/ASN1/ASN1Error.html">OpenSSL::ASN1::ASN1Error</a></li>
        
          
          
          <li><a href="../OpenSSL/ASN1/Constructive.html">OpenSSL::ASN1::Constructive</a></li>
        
          
          
          <li><a href="../OpenSSL/ASN1/Primitive.html">OpenSSL::ASN1::Primitive</a></li>
        
          
          
          <li><a href="../OpenSSL/BNError.html">OpenSSL::BNError</a></li>
        
          
          
          <li><a href="../OpenSSL/Buffering.html">OpenSSL::Buffering</a></li>
        
          
          
          <li><a href="../OpenSSL/Cipher.html">OpenSSL::Cipher</a></li>
        
          
          
          <li><a href="../OpenSSL/Cipher/Cipher.html">OpenSSL::Cipher::Cipher</a></li>
        
          
          
          <li><a href="../OpenSSL/Cipher/CipherError.html">OpenSSL::Cipher::CipherError</a></li>
        
          
          
          <li><a href="../OpenSSL/Config.html">OpenSSL::Config</a></li>
        
          
          
          <li><a href="../OpenSSL/ConfigError.html">OpenSSL::ConfigError</a></li>
        
          
          
          <li><a href="../OpenSSL/Digest.html">OpenSSL::Digest</a></li>
        
          
          
          <li><a href="../OpenSSL/Digest/Digest.html">OpenSSL::Digest::Digest</a></li>
        
          
          
          <li><a href="../OpenSSL/Digest/DigestError.html">OpenSSL::Digest::DigestError</a></li>
        
          
          
          <li><a href="../OpenSSL/Engine.html">OpenSSL::Engine</a></li>
        
          
          
          <li><a href="../OpenSSL/Engine/EngineError.html">OpenSSL::Engine::EngineError</a></li>
        
          
          
          <li><a href="../OpenSSL/HMAC.html">OpenSSL::HMAC</a></li>
        
          
          
          <li><a href="../OpenSSL/HMACError.html">OpenSSL::HMACError</a></li>
        
          
          
          <li><a href="../OpenSSL/Netscape.html">OpenSSL::Netscape</a></li>
        
          
          
          <li><a href="../OpenSSL/Netscape/SPKI.html">OpenSSL::Netscape::SPKI</a></li>
        
          
          
          <li><a href="../OpenSSL/Netscape/SPKIError.html">OpenSSL::Netscape::SPKIError</a></li>
        
          
          
          <li><a href="../OpenSSL/OCSP.html">OpenSSL::OCSP</a></li>
        
          
          
          <li><a href="../OpenSSL/OCSP/BasicResponse.html">OpenSSL::OCSP::BasicResponse</a></li>
        
          
          
          <li><a href="../OpenSSL/OCSP/CertificateId.html">OpenSSL::OCSP::CertificateId</a></li>
        
          
          
          <li><a href="../OpenSSL/OCSP/OCSPError.html">OpenSSL::OCSP::OCSPError</a></li>
        
          
          
          <li><a href="../OpenSSL/OCSP/Request.html">OpenSSL::OCSP::Request</a></li>
        
          
          
          <li><a href="../OpenSSL/OCSP/Response.html">OpenSSL::OCSP::Response</a></li>
        
          
          
          <li><a href="../OpenSSL/OpenSSLError.html">OpenSSL::OpenSSLError</a></li>
        
          
          
          <li><a href="../OpenSSL/PKCS12.html">OpenSSL::PKCS12</a></li>
        
          
          
          <li><a href="../OpenSSL/PKCS12/PKCS12Error.html">OpenSSL::PKCS12::PKCS12Error</a></li>
        
          
          
          <li><a href="../OpenSSL/PKCS5.html">OpenSSL::PKCS5</a></li>
        
          
          
          <li><a href="../OpenSSL/PKCS5/PKCS5Error.html">OpenSSL::PKCS5::PKCS5Error</a></li>
        
          
          
          <li><a href="../OpenSSL/PKCS7.html">OpenSSL::PKCS7</a></li>
        
          
          
          <li><a href="../OpenSSL/PKCS7/PKCS7Error.html">OpenSSL::PKCS7::PKCS7Error</a></li>
        
          
          
          <li><a href="../OpenSSL/PKCS7/RecipientInfo.html">OpenSSL::PKCS7::RecipientInfo</a></li>
        
          
          
          <li><a href="../OpenSSL/PKCS7/SignerInfo.html">OpenSSL::PKCS7::SignerInfo</a></li>
        
          
          
          <li><a href="../OpenSSL/PKey.html">OpenSSL::PKey</a></li>
        
          
          
          <li><a href="../OpenSSL/PKey/DH.html">OpenSSL::PKey::DH</a></li>
        
          
          
          <li><a href="../OpenSSL/PKey/DHError.html">OpenSSL::PKey::DHError</a></li>
        
          
          
          <li><a href="../OpenSSL/PKey/DSA.html">OpenSSL::PKey::DSA</a></li>
        
          
          
          <li><a href="../OpenSSL/PKey/DSAError.html">OpenSSL::PKey::DSAError</a></li>
        
          
          
          <li><a href="../OpenSSL/PKey/EC.html">OpenSSL::PKey::EC</a></li>
        
          
          
          <li><a href="../OpenSSL/PKey/EC/Group.html">OpenSSL::PKey::EC::Group</a></li>
        
          
          
          <li><a href="../OpenSSL/PKey/EC/Group/Error.html">OpenSSL::PKey::EC::Group::Error</a></li>
        
          
          
          <li><a href="../OpenSSL/PKey/EC/Point.html">OpenSSL::PKey::EC::Point</a></li>
        
          
          
          <li><a href="../OpenSSL/PKey/EC/Point/Error.html">OpenSSL::PKey::EC::Point::Error</a></li>
        
          
          
          <li><a href="../OpenSSL/PKey/ECError.html">OpenSSL::PKey::ECError</a></li>
        
          
          
          <li><a href="../OpenSSL/PKey/PKey.html">OpenSSL::PKey::PKey</a></li>
        
          
          
          <li><a href="../OpenSSL/PKey/PKeyError.html">OpenSSL::PKey::PKeyError</a></li>
        
          
          
          <li><a href="../OpenSSL/PKey/RSA.html">OpenSSL::PKey::RSA</a></li>
        
          
          
          <li><a href="../OpenSSL/PKey/RSAError.html">OpenSSL::PKey::RSAError</a></li>
        
          
          
          <li><a href="../OpenSSL/Random.html">OpenSSL::Random</a></li>
        
          
          
          <li><a href="../OpenSSL/Random/RandomError.html">OpenSSL::Random::RandomError</a></li>
        
          
          
          <li><a href="../OpenSSL/SSL.html">OpenSSL::SSL</a></li>
        
          
          
          <li><a href="../OpenSSL/SSL/SSLContext.html">OpenSSL::SSL::SSLContext</a></li>
        
          
          
          <li><a href="../OpenSSL/SSL/SSLError.html">OpenSSL::SSL::SSLError</a></li>
        
          
          
          <li><a href="../OpenSSL/SSL/Session.html">OpenSSL::SSL::Session</a></li>
        
          
          
          <li><a href="../OpenSSL/SSL/Session/SessionError.html">OpenSSL::SSL::Session::SessionError</a></li>
        
          
          
          <li><a href="../OpenSSL/X509.html">OpenSSL::X509</a></li>
        
          
          
          <li><a href="../OpenSSL/X509/Attribute.html">OpenSSL::X509::Attribute</a></li>
        
          
          
          <li><a href="../OpenSSL/X509/AttributeError.html">OpenSSL::X509::AttributeError</a></li>
        
          
          
          <li><a href="../OpenSSL/X509/CRL.html">OpenSSL::X509::CRL</a></li>
        
          
          
          <li><a href="../OpenSSL/X509/CRLError.html">OpenSSL::X509::CRLError</a></li>
        
          
          
          <li><a href="../OpenSSL/X509/Certificate.html">OpenSSL::X509::Certificate</a></li>
        
          
          
          <li><a href="../OpenSSL/X509/CertificateError.html">OpenSSL::X509::CertificateError</a></li>
        
          
          
          <li><a href="../OpenSSL/X509/Extension.html">OpenSSL::X509::Extension</a></li>
        
          
          
          <li><a href="../OpenSSL/X509/ExtensionError.html">OpenSSL::X509::ExtensionError</a></li>
        
          
          
          <li><a href="../OpenSSL/X509/ExtensionFactory.html">OpenSSL::X509::ExtensionFactory</a></li>
        
          
          
          <li><a href="../OpenSSL/X509/Name.html">OpenSSL::X509::Name</a></li>
        
          
          
          <li><a href="../OpenSSL/X509/Name/RFC2253DN.html">OpenSSL::X509::Name::RFC2253DN</a></li>
        
          
          
          <li><a href="../OpenSSL/X509/NameError.html">OpenSSL::X509::NameError</a></li>
        
          
          
          <li><a href="../OpenSSL/X509/Request.html">OpenSSL::X509::Request</a></li>
        
          
          
          <li><a href="../OpenSSL/X509/RequestError.html">OpenSSL::X509::RequestError</a></li>
        
          
          
          <li><a href="../OpenSSL/X509/Revoked.html">OpenSSL::X509::Revoked</a></li>
        
          
          
          <li><a href="../OpenSSL/X509/RevokedError.html">OpenSSL::X509::RevokedError</a></li>
        
          
          
          <li><a href="../OpenSSL/X509/Store.html">OpenSSL::X509::Store</a></li>
        
          
          
          <li><a href="../OpenSSL/X509/StoreError.html">OpenSSL::X509::StoreError</a></li>
        
          
          
          <li><a href="../unknown.html">unknown</a></li>
        
        </ul>
        <div id="no-class-search-results" style="display: none;">No matching classes.</div>
      </div>

      
    </div>
  </div> <!-- metadata -->
  <div class='adzbox'  id="azk83167">
    
  </div> 
  <div id="documentation">
    <h1 class="class">OpenSSL::Cipher</h1>

    <div id="description" class="description">
      
<p>Provides symmetric algorithms for encryption and decryption. The algorithms
that are available depend on the particular version of <a
href="../OpenSSL.html">OpenSSL</a> that is installed.</p>

<h3 id="class-OpenSSL::Cipher-label-Listing+all+supported+algorithms">Listing all supported algorithms<span><a href="#class-OpenSSL::Cipher-label-Listing+all+supported+algorithms">&para;</a> <a href="#documentation">&uarr;</a></span></h3>

<p>A list of supported algorithms can be obtained by</p>

<pre>puts OpenSSL::Cipher.ciphers</pre>

<h3 id="class-OpenSSL::Cipher-label-Instantiating+a+Cipher">Instantiating a <a href="Cipher/Cipher.html">Cipher</a><span><a href="#class-OpenSSL::Cipher-label-Instantiating+a+Cipher">&para;</a> <a href="#documentation">&uarr;</a></span></h3>

<p>There are several ways to create a <a href="Cipher/Cipher.html">Cipher</a>
instance. Generally, a <a href="Cipher/Cipher.html">Cipher</a> algorithm is
categorized by its name, the key length in bits and the cipher mode to be
used. The most generic way to create a <a
href="Cipher/Cipher.html">Cipher</a> is the following</p>

<pre>cipher = OpenSSL::Cipher.new('&lt;name&gt;-&lt;key length&gt;-&lt;mode&gt;')</pre>

<p>That is, a string consisting of the hyphenated concatenation of the
individual components name, key length and mode. Either all uppercase or
all lowercase strings may be used, for example:</p>

<pre>cipher = OpenSSL::Cipher.new('AES-128-CBC')</pre>

<p>For each algorithm supported, there is a class defined under the <a
href="Cipher/Cipher.html">Cipher</a> class that goes by the name of the
cipher, e.g. to obtain an instance of AES, you could also use</p>

<pre># these are equivalent
cipher = OpenSSL::Cipher::AES.new(128, :CBC)
cipher = OpenSSL::Cipher::AES.new(128, 'CBC')
cipher = OpenSSL::Cipher::AES.new('128-CBC')</pre>

<p>Finally, due to its wide-spread use, there are also extra classes defined
for the different key sizes of AES</p>

<pre>cipher = OpenSSL::Cipher::AES128.new(:CBC)
cipher = OpenSSL::Cipher::AES192.new(:CBC)
cipher = OpenSSL::Cipher::AES256.new(:CBC)</pre>

<h3 id="class-OpenSSL::Cipher-label-Choosing+either+encryption+or+decryption+mode">Choosing either encryption or decryption mode<span><a href="#class-OpenSSL::Cipher-label-Choosing+either+encryption+or+decryption+mode">&para;</a> <a href="#documentation">&uarr;</a></span></h3>

<p>Encryption and decryption are often very similar operations for symmetric
algorithms, this is reflected by not having to choose different classes for
either operation, both can be done using the same class. Still, after
obtaining a <a href="Cipher/Cipher.html">Cipher</a> instance, we need to
tell the instance what it is that we intend to do with it, so we need to
call either</p>

<pre>cipher.encrypt</pre>

<p>or</p>

<pre>cipher.decrypt</pre>

<p>on the <a href="Cipher/Cipher.html">Cipher</a> instance. This should be the
first call after creating the instance, otherwise configuration that has
already been set could get lost in the process.</p>

<h3 id="class-OpenSSL::Cipher-label-Choosing+a+key">Choosing a key<span><a href="#class-OpenSSL::Cipher-label-Choosing+a+key">&para;</a> <a href="#documentation">&uarr;</a></span></h3>

<p>Symmetric encryption requires a key that is the same for the encrypting and
for the decrypting party and after initial key establishment should be kept
as private information. There are a lot of ways to create insecure keys,
the most notable is to simply take a password as the key without processing
the password further. A simple and secure way to create a key for a
particular <a href="Cipher/Cipher.html">Cipher</a> is</p>

<pre>cipher = OpenSSL::AES256.new(:CFB)
cipher.encrypt
key = cipher.random_key # also sets the generated key on the Cipher</pre>

<p>If you absolutely need to use passwords as encryption keys, you should use
Password-Based Key Derivation Function 2 (PBKDF2) by generating the key
with the help of the functionality provided by <a
href="PKCS5.html#method-c-pbkdf2_hmac_sha1">OpenSSL::PKCS5.pbkdf2_hmac_sha1</a>
or <a
href="PKCS5.html#method-c-pbkdf2_hmac">OpenSSL::PKCS5.pbkdf2_hmac</a>.</p>

<p>Although there is <a
href="Cipher.html#method-i-pkcs5_keyivgen">#pkcs5_keyivgen</a>, its use is
deprecated and it should only be used in legacy applications because it
does not use the newer PKCS#5 v2 algorithms.</p>

<h3 id="class-OpenSSL::Cipher-label-Choosing+an+IV">Choosing an IV<span><a href="#class-OpenSSL::Cipher-label-Choosing+an+IV">&para;</a> <a href="#documentation">&uarr;</a></span></h3>

<p>The cipher modes CBC, CFB, OFB and CTR all need an "initialization vector",
or short, IV. ECB mode is the only mode that does not require an IV, but
there is almost no legitimate use case for this mode because of the fact
that it does not sufficiently hide plaintext patterns. Therefore</p>

<p><strong>You should never use ECB mode unless you are absolutely sure that
you absolutely need it</strong></p>

<p>Because of this, you will end up with a mode that explicitly requires an IV
in any case. Note that for backwards compatibility reasons, setting an IV
is not explicitly mandated by the <a href="Cipher/Cipher.html">Cipher</a>
API. If not set, <a href="../OpenSSL.html">OpenSSL</a> itself defaults to
an all-zeroes IV ("\0", not the character). Although the IV can be seen as
public information, i.e. it may be transmitted in public once generated, it
should still stay unpredictable to prevent certain kinds of attacks.
Therefore, ideally</p>

<p><strong>Always create a secure random IV for every encryption of your <a
href="Cipher/Cipher.html">Cipher</a></strong></p>

<p>A new, random IV should be created for every encryption of data. Think of
the IV as a nonce (number used once) - it's public but random and
unpredictable. A secure random IV can be created as follows</p>

<pre>cipher = ...
cipher.encrypt
key = cipher.random_key
iv = cipher.random_iv # also sets the generated IV on the Cipher

Although the key is generally a random value, too, it is a bad choice
as an IV. There are elaborate ways how an attacker can take advantage
of such an IV. As a general rule of thumb, exposing the key directly
or indirectly should be avoided at all cost and exceptions only be
made with good reason.</pre>

<h3 id="class-OpenSSL::Cipher-label-Calling+Cipher%23final">Calling <a href="Cipher.html#method-i-final">#final</a><span><a href="#class-OpenSSL::Cipher-label-Calling+Cipher%23final">&para;</a> <a href="#documentation">&uarr;</a></span></h3>

<p>ECB (which should not be used) and CBC are both block-based modes. This
means that unlike for the other streaming-based modes, they operate on
fixed-size blocks of data, and therefore they require a "finalization" step
to produce or correctly decrypt the last block of data by appropriately
handling some form of padding. Therefore it is essential to add the output
of <a href="Cipher.html#method-i-final">#final</a> to your
encryption/decryption buffer or you will end up with decryption errors or
truncated data.</p>

<p>Although this is not really necessary for streaming-mode ciphers, it is
still recommended to apply the same pattern of adding the output of <a
href="Cipher.html#method-i-final">#final</a> there as well - it also
enables you to switch between modes more easily in the future.</p>

<h3 id="class-OpenSSL::Cipher-label-Encrypting+and+decrypting+some+data">Encrypting and decrypting some data<span><a href="#class-OpenSSL::Cipher-label-Encrypting+and+decrypting+some+data">&para;</a> <a href="#documentation">&uarr;</a></span></h3>

<pre class="ruby"><span class="ruby-identifier">data</span> = <span class="ruby-string">&quot;Very, very confidential data&quot;</span>

<span class="ruby-identifier">cipher</span> = <span class="ruby-constant">OpenSSL</span><span class="ruby-operator">::</span><span class="ruby-constant">Cipher</span><span class="ruby-operator">::</span><span class="ruby-constant">AES</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">128</span>, :<span class="ruby-constant">CBC</span>)
<span class="ruby-identifier">cipher</span>.<span class="ruby-identifier">encrypt</span>
<span class="ruby-identifier">key</span> = <span class="ruby-identifier">cipher</span>.<span class="ruby-identifier">random_key</span>
<span class="ruby-identifier">iv</span> = <span class="ruby-identifier">cipher</span>.<span class="ruby-identifier">random_iv</span>

<span class="ruby-identifier">encrypted</span> = <span class="ruby-identifier">cipher</span>.<span class="ruby-identifier">update</span>(<span class="ruby-identifier">data</span>) <span class="ruby-operator">+</span> <span class="ruby-identifier">cipher</span>.<span class="ruby-identifier">final</span>
<span class="ruby-operator">...</span>
<span class="ruby-identifier">decipher</span> = <span class="ruby-constant">OpenSSL</span><span class="ruby-operator">::</span><span class="ruby-constant">Cipher</span><span class="ruby-operator">::</span><span class="ruby-constant">AES</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">128</span>, :<span class="ruby-constant">CBC</span>)
<span class="ruby-identifier">decipher</span>.<span class="ruby-identifier">decrypt</span>
<span class="ruby-identifier">decipher</span>.<span class="ruby-identifier">key</span> = <span class="ruby-identifier">key</span>
<span class="ruby-identifier">decipher</span>.<span class="ruby-identifier">iv</span> = <span class="ruby-identifier">iv</span>

<span class="ruby-identifier">plain</span> = <span class="ruby-identifier">decipher</span>.<span class="ruby-identifier">update</span>(<span class="ruby-identifier">encrypted</span>) <span class="ruby-operator">+</span> <span class="ruby-identifier">decipher</span>.<span class="ruby-identifier">final</span>

<span class="ruby-identifier">puts</span> <span class="ruby-identifier">data</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">plain</span> <span class="ruby-comment">#=&gt; true</span>
</pre>

    </div><!-- description -->

    
    
    
    <div id="5Buntitled-5D" class="documentation-section">
      

      

      

      

      <!-- Methods -->
      
      <div id="public-class-method-details" class="method-section section">
        <h3 class="section-header">Public Class Methods</h3>

      
        <div id="ciphers-method" class="method-detail ">
          <a name="method-c-ciphers"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">ciphers &rarr; array[string...]</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the names of all available ciphers in an array.</p>
            

            
            <div class="method-source-code" id="ciphers-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
ossl_s_ciphers(VALUE self)
{
    VALUE ary;

    ary = rb_ary_new();
    OBJ_NAME_do_all_sorted(OBJ_NAME_TYPE_CIPHER_METH,
                    (void(*)(const OBJ_NAME*,void*))add_cipher_name_to_ary,
                    (void*)ary);

    return ary;
}
            </pre> 
            </div><!-- ciphers-source -->
            
          </div>

          

          
        </div><!-- ciphers-method -->
      
        <div id="new-method" class="method-detail ">
          <a name="method-c-new"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">new(string) &rarr; cipher</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>The string must contain a valid cipher name like “AES-128-CBC” or “3DES”.</p>

<p>A list of cipher names is available by calling <a
href="Cipher.html#method-c-ciphers">::ciphers</a>.</p>
            

            
            <div class="method-source-code" id="new-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
ossl_cipher_initialize(VALUE self, VALUE str)
{
    EVP_CIPHER_CTX *ctx;
    const EVP_CIPHER *cipher;
    char *name;
    unsigned char key[EVP_MAX_KEY_LENGTH];

    name = StringValuePtr(str);
    GetCipherInit(self, ctx);
    if (ctx) {
        ossl_raise(rb_eRuntimeError, &quot;Cipher already inititalized!&quot;);
    }
    AllocCipher(self, ctx);
    EVP_CIPHER_CTX_init(ctx);
    if (!(cipher = EVP_get_cipherbyname(name))) {
        ossl_raise(rb_eRuntimeError, &quot;unsupported cipher algorithm (%s)&quot;, name);
    }
    /*
     * The EVP which has EVP_CIPH_RAND_KEY flag (such as DES3) allows
     * uninitialized key, but other EVPs (such as AES) does not allow it.
     * Calling EVP_CipherUpdate() without initializing key causes SEGV so we
     * set the data filled with &quot;\0&quot; as the key by default.
     */
    memset(key, 0, EVP_MAX_KEY_LENGTH);
    if (EVP_CipherInit_ex(ctx, cipher, NULL, key, NULL, -1) != 1)
        ossl_raise(eCipherError, NULL);

    return self;
}
            </pre> 
            </div><!-- new-source -->
            
          </div>

          

          
        </div><!-- new-method -->
      
      </div><!-- public-class-method-details -->
    
      <div id="public-instance-method-details" class="method-section section">
        <h3 class="section-header">Public Instance Methods</h3>

      
        <div id="decrypt-method" class="method-detail ">
          <a name="method-i-decrypt"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">decrypt &rarr; self</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Initializes the <a href="Cipher/Cipher.html">Cipher</a> for decryption.</p>

<p>Make sure to call <a href="Cipher.html#method-i-encrypt">#encrypt</a> or <a
href="Cipher.html#method-i-decrypt">#decrypt</a> before using any of the
following methods:</p>
<ul><li><dl class="rdoc-list label-list"><dt>key=, iv=, <a href="Cipher.html#method-i-random_key">#random_key</a>, <a href="Cipher.html#method-i-random_iv">#random_iv</a>, <a href="Cipher.html#method-i-pkcs5_keyivgen">#pkcs5_keyivgen</a>
<dd></dd></dl>
</li></ul>

<p>Internally calls EVP_CipherInit_ex(ctx, NULL, NULL, NULL, NULL, 0).</p>
            

            
            <div class="method-source-code" id="decrypt-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
ossl_cipher_decrypt(int argc, VALUE *argv, VALUE self)
{
    return ossl_cipher_init(argc, argv, self, 0);
}
            </pre> 
            </div><!-- decrypt-source -->
            
          </div>

          

          
        </div><!-- decrypt-method -->
      
        <div id="encrypt-method" class="method-detail ">
          <a name="method-i-encrypt"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">encrypt &rarr; self</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Initializes the <a href="Cipher/Cipher.html">Cipher</a> for encryption.</p>

<p>Make sure to call <a href="Cipher.html#method-i-encrypt">#encrypt</a> or <a
href="Cipher.html#method-i-decrypt">#decrypt</a> before using any of the
following methods:</p>
<ul><li><dl class="rdoc-list label-list"><dt>key=, iv=, <a href="Cipher.html#method-i-random_key">#random_key</a>, <a href="Cipher.html#method-i-random_iv">#random_iv</a>, <a href="Cipher.html#method-i-pkcs5_keyivgen">#pkcs5_keyivgen</a>
<dd></dd></dl>
</li></ul>

<p>Internally calls EVP_CipherInit_ex(ctx, NULL, NULL, NULL, NULL, 1).</p>
            

            
            <div class="method-source-code" id="encrypt-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
ossl_cipher_encrypt(int argc, VALUE *argv, VALUE self)
{
    return ossl_cipher_init(argc, argv, self, 1);
}
            </pre> 
            </div><!-- encrypt-source -->
            
          </div>

          

          
        </div><!-- encrypt-method -->
      
        <div id="final-method" class="method-detail ">
          <a name="method-i-final"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">final &rarr; string</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the remaining data held in the cipher object.  Further calls to <a
href="Cipher.html#method-i-update">#update</a> or <a
href="Cipher.html#method-i-final">#final</a> will return garbage.</p>

<p>See EVP_CipherFinal_ex for further information.</p>
            

            
            <div class="method-source-code" id="final-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
ossl_cipher_final(VALUE self)
{
    EVP_CIPHER_CTX *ctx;
    int out_len;
    VALUE str;

    GetCipher(self, ctx);
    str = rb_str_new(0, EVP_CIPHER_CTX_block_size(ctx));
    if (!EVP_CipherFinal_ex(ctx, (unsigned char *)RSTRING_PTR(str), &amp;out_len))
        ossl_raise(eCipherError, NULL);
    assert(out_len &lt;= RSTRING_LEN(str));
    rb_str_set_len(str, out_len);

    return str;
}
            </pre> 
            </div><!-- final-source -->
            
          </div>

          

          
        </div><!-- final-method -->
      
        <div id="iv-3D-method" class="method-detail ">
          <a name="method-i-iv-3D"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">iv = string &rarr; string</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Sets the cipher IV. Please note that since you should never be using ECB
mode, an IV is always explicitly required and should be set prior to
encryption. The IV itself can be safely transmitted in public, but it
should be unpredictable to prevent certain kinds of attacks. You may use <a
href="Cipher.html#method-i-random_iv">#random_iv</a> to create a secure
random IV.</p>

<p>Only call this method after calling <a
href="Cipher.html#method-i-encrypt">#encrypt</a> or <a
href="Cipher.html#method-i-decrypt">#decrypt</a>.</p>

<p>If not explicitly set, the <a href="../OpenSSL.html">OpenSSL</a> default of
an all-zeroes (“\0”) IV is used.</p>
            

            
            <div class="method-source-code" id="iv-3D-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
ossl_cipher_set_iv(VALUE self, VALUE iv)
{
    EVP_CIPHER_CTX *ctx;

    StringValue(iv);
    GetCipher(self, ctx);

    if (RSTRING_LEN(iv) &lt; EVP_CIPHER_CTX_iv_length(ctx))
        ossl_raise(eCipherError, &quot;iv length too short&quot;);

    if (EVP_CipherInit_ex(ctx, NULL, NULL, NULL, (unsigned char *)RSTRING_PTR(iv), -1) != 1)
        ossl_raise(eCipherError, NULL);

    return iv;
}
            </pre> 
            </div><!-- iv-3D-source -->
            
          </div>

          

          
        </div><!-- iv-3D-method -->
      
        <div id="key-3D-method" class="method-detail ">
          <a name="method-i-key-3D"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">key = string &rarr; string</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Sets the cipher key. To generate a key, you should either use a secure
random byte string or, if the key is to be derived from a password, you
should rely on PBKDF2 functionality provided by <a
href="PKCS5.html">OpenSSL::PKCS5</a>. To generate a secure random-based
key, <a href="Cipher.html#method-i-random_key">#random_key</a> may be used.</p>

<p>Only call this method after calling <a
href="Cipher.html#method-i-encrypt">#encrypt</a> or <a
href="Cipher.html#method-i-decrypt">#decrypt</a>.</p>
            

            
            <div class="method-source-code" id="key-3D-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
ossl_cipher_set_key(VALUE self, VALUE key)
{
    EVP_CIPHER_CTX *ctx;

    StringValue(key);
    GetCipher(self, ctx);

    if (RSTRING_LEN(key) &lt; EVP_CIPHER_CTX_key_length(ctx))
        ossl_raise(eCipherError, &quot;key length too short&quot;);

    if (EVP_CipherInit_ex(ctx, NULL, NULL, (unsigned char *)RSTRING_PTR(key), NULL, -1) != 1)
        ossl_raise(eCipherError, NULL);

    return key;
}
            </pre> 
            </div><!-- key-3D-source -->
            
          </div>

          

          
        </div><!-- key-3D-method -->
      
        <div id="key_len-3D-method" class="method-detail ">
          <a name="method-i-key_len-3D"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">key_len = integer &rarr; integer</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Sets the key length of the cipher.  If the cipher is a fixed length cipher
then attempting to set the key length to any value other than the fixed
value is an error.</p>

<p>Under normal circumstances you do not need to call this method (and
probably shouldn’t).</p>

<p>See EVP_CIPHER_CTX_set_key_length for further information.</p>
            

            
            <div class="method-source-code" id="key_len-3D-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
ossl_cipher_set_key_length(VALUE self, VALUE key_length)
{
    int len = NUM2INT(key_length);
    EVP_CIPHER_CTX *ctx;

    GetCipher(self, ctx);
    if (EVP_CIPHER_CTX_set_key_length(ctx, len) != 1)
        ossl_raise(eCipherError, NULL);

    return key_length;
}
            </pre> 
            </div><!-- key_len-3D-source -->
            
          </div>

          

          
        </div><!-- key_len-3D-method -->
      
        <div id="name-method" class="method-detail ">
          <a name="method-i-name"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">name &rarr; string</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the name of the cipher which may differ slightly from the original
name provided.</p>
            

            
            <div class="method-source-code" id="name-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
ossl_cipher_name(VALUE self)
{
    EVP_CIPHER_CTX *ctx;

    GetCipher(self, ctx);

    return rb_str_new2(EVP_CIPHER_name(EVP_CIPHER_CTX_cipher(ctx)));
}
            </pre> 
            </div><!-- name-source -->
            
          </div>

          

          
        </div><!-- name-method -->
      
        <div id="padding-3D-method" class="method-detail ">
          <a name="method-i-padding-3D"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">padding = integer &rarr; integer</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Enables or disables padding. By default encryption operations are padded
using standard block padding and the padding is checked and removed when
decrypting. If the pad parameter is zero then no padding is performed, the
total amount of data encrypted or decrypted must then be a multiple of the
block size or an error will occur.</p>

<p>See EVP_CIPHER_CTX_set_padding for further information.</p>
            

            
            <div class="method-source-code" id="padding-3D-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
ossl_cipher_set_padding(VALUE self, VALUE padding)
{
    EVP_CIPHER_CTX *ctx;
    int pad = NUM2INT(padding);

    GetCipher(self, ctx);
    if (EVP_CIPHER_CTX_set_padding(ctx, pad) != 1)
        ossl_raise(eCipherError, NULL);
    return padding;
}
            </pre> 
            </div><!-- padding-3D-source -->
            
          </div>

          

          
        </div><!-- padding-3D-method -->
      
        <div id="pkcs5_keyivgen-method" class="method-detail ">
          <a name="method-i-pkcs5_keyivgen"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">pkcs5_keyivgen(pass [, salt [, iterations [, digest]]] ) &rarr; nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Generates and sets the key/IV based on a password.</p>

<p>WARNING: This method is only <a href="PKCS5.html">PKCS5</a> v1.5 compliant
when using RC2, RC4-40, or DES with MD5 or SHA1. Using anything else (like
AES) will generate the key/iv using an <a
href="../OpenSSL.html">OpenSSL</a> specific method. This method is
deprecated and should no longer be used. Use a <a
href="PKCS5.html">PKCS5</a> v2 key generation method from <a
href="PKCS5.html">OpenSSL::PKCS5</a> instead.</p>

<h3 id="method-i-pkcs5_keyivgen-label-Parameters">Parameters<span><a href="#method-i-pkcs5_keyivgen-label-Parameters">&para;</a> <a href="#documentation">&uarr;</a></span></h3>

<p><code>salt</code> must be an 8 byte string if provided.
<code>iterations</code> is a integer with a default of 2048.
<code>digest</code> is a <a href="Digest.html">Digest</a> object that
defaults to 'MD5'</p>

<p>A minimum of 1000 iterations is recommended.</p>
            

            
            <div class="method-source-code" id="pkcs5_keyivgen-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
ossl_cipher_pkcs5_keyivgen(int argc, VALUE *argv, VALUE self)
{
    EVP_CIPHER_CTX *ctx;
    const EVP_MD *digest;
    VALUE vpass, vsalt, viter, vdigest;
    unsigned char key[EVP_MAX_KEY_LENGTH], iv[EVP_MAX_IV_LENGTH], *salt = NULL;
    int iter;

    rb_scan_args(argc, argv, &quot;13&quot;, &amp;vpass, &amp;vsalt, &amp;viter, &amp;vdigest);
    StringValue(vpass);
    if(!NIL_P(vsalt)){
        StringValue(vsalt);
        if(RSTRING_LEN(vsalt) != PKCS5_SALT_LEN)
            ossl_raise(eCipherError, &quot;salt must be an 8-octet string&quot;);
        salt = (unsigned char *)RSTRING_PTR(vsalt);
    }
    iter = NIL_P(viter) ? 2048 : NUM2INT(viter);
    digest = NIL_P(vdigest) ? EVP_md5() : GetDigestPtr(vdigest);
    GetCipher(self, ctx);
    EVP_BytesToKey(EVP_CIPHER_CTX_cipher(ctx), digest, salt,
                   (unsigned char *)RSTRING_PTR(vpass), RSTRING_LENINT(vpass), iter, key, iv);
    if (EVP_CipherInit_ex(ctx, NULL, NULL, key, iv, -1) != 1)
        ossl_raise(eCipherError, NULL);
    OPENSSL_cleanse(key, sizeof key);
    OPENSSL_cleanse(iv, sizeof iv);

    return Qnil;
}
            </pre> 
            </div><!-- pkcs5_keyivgen-source -->
            
          </div>

          

          
        </div><!-- pkcs5_keyivgen-method -->
      
        <div id="random_iv-method" class="method-detail ">
          <a name="method-i-random_iv"></a>

          
          <div class="method-heading">
            <span class="method-name">random_iv</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          
          <div>
  
            
            <p>Generate, set, and return a random iv. You must call cipher.encrypt or
cipher.decrypt before calling this method.</p>
            

            
            <div class="method-source-code" id="random_iv-source">
              <pre> <!-- method.markup_code 290 -->
               <span class="ruby-comment"># File openssl/lib/openssl/cipher.rb, line 54</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">random_iv</span>
  <span class="ruby-identifier">str</span> = <span class="ruby-constant">OpenSSL</span><span class="ruby-operator">::</span><span class="ruby-constant">Random</span>.<span class="ruby-identifier">random_bytes</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">iv_len</span>)
  <span class="ruby-keyword">self</span>.<span class="ruby-identifier">iv</span> = <span class="ruby-identifier">str</span>
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">str</span>
<span class="ruby-keyword">end</span>
            </pre> 
            </div><!-- random_iv-source -->
            
          </div>

          

          
        </div><!-- random_iv-method -->
      
        <div id="random_key-method" class="method-detail ">
          <a name="method-i-random_key"></a>

          
          <div class="method-heading">
            <span class="method-name">random_key</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          
          <div>
  
            
            <p>Generate, set, and return a random key. You must call cipher.encrypt or
cipher.decrypt before calling this method.</p>
            

            
            <div class="method-source-code" id="random_key-source">
              <pre> <!-- method.markup_code 290 -->
               <span class="ruby-comment"># File openssl/lib/openssl/cipher.rb, line 46</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">random_key</span>
  <span class="ruby-identifier">str</span> = <span class="ruby-constant">OpenSSL</span><span class="ruby-operator">::</span><span class="ruby-constant">Random</span>.<span class="ruby-identifier">random_bytes</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">key_len</span>)
  <span class="ruby-keyword">self</span>.<span class="ruby-identifier">key</span> = <span class="ruby-identifier">str</span>
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">str</span>
<span class="ruby-keyword">end</span>
            </pre> 
            </div><!-- random_key-source -->
            
          </div>

          

          
        </div><!-- random_key-method -->
      
        <div id="reset-method" class="method-detail ">
          <a name="method-i-reset"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">reset &rarr; self</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Fully resets the internal state of the <a
href="Cipher/Cipher.html">Cipher</a>. By using this, the same <a
href="Cipher/Cipher.html">Cipher</a> instance may be used several times for
en- or decryption tasks.</p>

<p>Internally calls EVP_CipherInit_ex(ctx, NULL, NULL, NULL, NULL, -1).</p>
            

            
            <div class="method-source-code" id="reset-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
ossl_cipher_reset(VALUE self)
{
    EVP_CIPHER_CTX *ctx;

    GetCipher(self, ctx);
    if (EVP_CipherInit_ex(ctx, NULL, NULL, NULL, NULL, -1) != 1)
        ossl_raise(eCipherError, NULL);

    return self;
}
            </pre> 
            </div><!-- reset-source -->
            
          </div>

          

          
        </div><!-- reset-method -->
      
        <div id="update-method" class="method-detail ">
          <a name="method-i-update"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">update(data [, buffer]) &rarr; string or buffer</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Encrypts data in a streaming fashion. Hand consecutive blocks of data to
the <code>update</code> method in order to encrypt it. Returns the
encrypted data chunk. When done, the output of <a
href="Cipher.html#method-i-final">#final</a> should be additionally added
to the result.</p>

<h3 id="method-i-update-label-Parameters">Parameters<span><a href="#method-i-update-label-Parameters">&para;</a> <a href="#documentation">&uarr;</a></span></h3>

<p><code>data</code> is a nonempty string. <code>buffer</code> is an optional
string to store the result.</p>
            

            
            <div class="method-source-code" id="update-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
ossl_cipher_update(int argc, VALUE *argv, VALUE self)
{
    EVP_CIPHER_CTX *ctx;
    unsigned char *in;
    int in_len, out_len;
    VALUE data, str;

    rb_scan_args(argc, argv, &quot;11&quot;, &amp;data, &amp;str);

    StringValue(data);
    in = (unsigned char *)RSTRING_PTR(data);
    if ((in_len = RSTRING_LENINT(data)) == 0)
        ossl_raise(rb_eArgError, &quot;data must not be empty&quot;);
    GetCipher(self, ctx);
    out_len = in_len+EVP_CIPHER_CTX_block_size(ctx);

    if (NIL_P(str)) {
        str = rb_str_new(0, out_len);
    } else {
        StringValue(str);
        rb_str_resize(str, out_len);
    }

    if (!EVP_CipherUpdate(ctx, (unsigned char *)RSTRING_PTR(str), &amp;out_len, in, in_len))
        ossl_raise(eCipherError, NULL);
    assert(out_len &lt; RSTRING_LEN(str));
    rb_str_set_len(str, out_len);

    return str;
}
            </pre> 
            </div><!-- update-source -->
            
          </div>

          

          
        </div><!-- update-method -->
      
      </div><!-- public-instance-method-details -->
    
    </div><!-- 5Buntitled-5D -->
  
  <div id='tx_Cipher_versioned' class='associated_wrapper'></div><script type='text/javascript'>$("#tx_Cipher_versioned").load("/associated/1.9.3/Cipher.html");</script> <div id='tx_Cipher' class='associated_wrapper'></div><script type='text/javascript'>$("#tx_Cipher").load("/associated/Cipher.html");</script> 
      
  </div><!-- documentation -->
  <div id='dynamic'>
  </div>
      
<div class='grids wrapper' id="footer">
  <p><small>This page was generated for Ruby 1.9.3</small></p> 
  
   <p><a href="http://www.ruby-doc.org">Ruby-doc.org</a> is a service of <a href="http://www.jamesbritt.com">James Britt</a> and <a href="http://www.neurogami.com">Neurogami</a>, an <a href="http://www.neurogami.com">application development company in Scottsdale, AZ</a>.</p>
 
    <p><small>Generated with Ruby-doc Rdoc Generator 0.26.0</small>.</p>
  </div>
</div>
  
 <script type='text/javascript'>
$(document).ready(function() {
      $.ajaxSetup({ cache: false });
      $("#vulns-alert").load("/associated/vulns.html");
    });

    </script>


 
    <script type='text/javascript'>

  function loadPlus(plusdocs){
    var img_h = $("img.carbonad-image").css('height');
    //if(img_h != undefined) { //---
      $(plusdocs).find("div[class='associated_wrapper']").each (function() {
          $("#" + this.id).append($(plusdocs).find("#" + this.id ));
          });
    //} // ---
  } // end loadPlusdocs


$(document).ready(function() {
    $.ajaxSetup({ cache: false });
      $.get('/associated/1.9.3/plus_Cipher.html', 
      function(plusdocs) {
      setTimeout(function() {
        loadPlus(plusdocs);
        }, 2000);
      }
      );
    });
</script>
		
</body>
</html>


